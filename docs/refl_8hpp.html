<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>refl-cpp: refl.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">refl-cpp
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('refl_8hpp.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">refl.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;array&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &lt;tuple&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;ostream&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;iomanip&gt;</code><br />
</div>
<p><a href="refl_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1unique__ptr.html">std::unique_ptr&lt; T, Deleter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1shared__ptr.html">std::shared_ptr&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1weak__ptr.html">std::weak_ptr&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1complex.html">std::complex&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1util_1_1const__string.html">refl::util::const_string&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a compile-time string.  <a href="structrefl_1_1util_1_1const__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1util_1_1type__list.html">refl::util::type_list&lt; Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a compile-time list of types provided as variadic template parameters.  <a href="structrefl_1_1util_1_1type__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1util_1_1type__list_3_01_t_01_4.html">refl::util::type_list&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1member_1_1field.html">refl::member::field</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An empty type which is equivalent to refl::member_descriptor_base::member_type when the reflected member is a field.  <a href="structrefl_1_1member_1_1field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1member_1_1function.html">refl::member::function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An empty type which is equivalent to refl::member_descriptor_base::member_type when the reflected member is a function.  <a href="structrefl_1_1member_1_1function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrefl_1_1descriptor_1_1type__descriptor.html">refl::descriptor::type_descriptor&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a reflected type.  <a href="classrefl_1_1descriptor_1_1type__descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrefl_1_1descriptor_1_1field__descriptor.html">refl::descriptor::field_descriptor&lt; T, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a reflected field.  <a href="classrefl_1_1descriptor_1_1field__descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrefl_1_1descriptor_1_1function__descriptor.html">refl::descriptor::function_descriptor&lt; T, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a reflected function.  <a href="classrefl_1_1descriptor_1_1function__descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1remove__qualifiers.html">refl::trait::remove_qualifiers&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all reference and cv-qualifiers from T.  <a href="structrefl_1_1trait_1_1remove__qualifiers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1is__reflectable.html">refl::trait::is_reflectable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether there is reflection metadata for the type T.  <a href="structrefl_1_1trait_1_1is__reflectable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1is__container.html">refl::trait::is_container&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether objects of the type T support member .begin() and .end() operations.  <a href="structrefl_1_1trait_1_1is__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1get_3_01_n_00_01type__list_3_01_ts_8_8_8_01_4_01_4.html">refl::trait::get&lt; N, type_list&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a member typedef type which is the N-th type in the provided type_list.  <a href="structrefl_1_1trait_1_1get_3_01_n_00_01type__list_3_01_ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1skip_3_01_n_00_01type__list_3_01_ts_8_8_8_01_4_01_4.html">refl::trait::skip&lt; N, type_list&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips the first N types in the provided type_list.  <a href="structrefl_1_1trait_1_1skip_3_01_n_00_01type__list_3_01_ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1as__type__list_3_01_t_3_01_ts_8_8_8_01_4_01_4.html">refl::trait::as_type_list&lt; T&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a member typedef type which is a type_list with template type parameters equivalent to the type parameters of the provided type.  <a href="structrefl_1_1trait_1_1as__type__list_3_01_t_3_01_ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1as__tuple_3_01_t_3_01_ts_8_8_8_01_4_01_4.html">refl::trait::as_tuple&lt; T&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a member typedef which is a std::tuple specialization with template type parameters equivalent to the type parameters of the provided type.  <a href="structrefl_1_1trait_1_1as__tuple_3_01_t_3_01_ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1reverse.html">refl::trait::reverse&lt; TypeList &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses a list of types.  <a href="structrefl_1_1trait_1_1reverse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1concat.html">refl::trait::concat&lt;... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates N lists together.  <a href="structrefl_1_1trait_1_1concat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1append.html">refl::trait::append&lt; T, TypeList &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a type to the list.  <a href="structrefl_1_1trait_1_1append.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1prepend.html">refl::trait::prepend&lt; T, TypeList &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends a type to the list.  <a href="structrefl_1_1trait_1_1prepend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1prepend.html">refl::trait::prepend&lt; T, TypeList &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends a type to the list.  <a href="structrefl_1_1trait_1_1prepend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1filter_3_01_predicate_00_01type__list_3_01_ts_8_8_8_01_4_01_4.html">refl::trait::filter&lt; Predicate, type_list&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a type_list according to a predicate template.  <a href="structrefl_1_1trait_1_1filter_3_01_predicate_00_01type__list_3_01_ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1map_3_01_mapper_00_01type__list_3_01_ts_8_8_8_01_4_01_4.html">refl::trait::map&lt; Mapper, type_list&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a type_list according to a predicate template.  <a href="structrefl_1_1trait_1_1map_3_01_mapper_00_01type__list_3_01_ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1is__instance.html">refl::trait::is_instance&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects whether T is a template specialization.  <a href="structrefl_1_1trait_1_1is__instance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1is__instance__of.html">refl::trait::is_instance_of&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects whther the type U is a template specialization of T.  <a href="structrefl_1_1trait_1_1is__instance__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1contains_3_01_t_00_01type__list_3_01_ts_8_8_8_01_4_01_4.html">refl::trait::contains&lt; T, type_list&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is contained in the list of types.  <a href="structrefl_1_1trait_1_1contains_3_01_t_00_01type__list_3_01_ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1contains__instance_3_01_t_00_01type__list_3_01_ts_8_8_8_01_4_01_4.html">refl::trait::contains_instance&lt; T, type_list&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether an instance of the template T is contained in the list of types.  <a href="structrefl_1_1trait_1_1contains__instance_3_01_t_00_01type__list_3_01_ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1contains__base_3_01_t_00_01type__list_3_01_ts_8_8_8_01_4_01_4.html">refl::trait::contains_base&lt; T, type_list&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a type deriving from T is contained in the list of types.  <a href="structrefl_1_1trait_1_1contains__base_3_01_t_00_01type__list_3_01_ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1index__of_3_01_t_00_01type__list_3_01_ts_8_8_8_01_4_01_4.html">refl::trait::index_of&lt; T, type_list&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the type in the type list, -1 if it doesn't exist.  <a href="structrefl_1_1trait_1_1index__of_3_01_t_00_01type__list_3_01_ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1index__of__base_3_01_t_00_01type__list_3_01_ts_8_8_8_01_4_01_4.html">refl::trait::index_of_base&lt; T, type_list&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the type in the type list that is derived from T, -1 if it doesn't exist.  <a href="structrefl_1_1trait_1_1index__of__base_3_01_t_00_01type__list_3_01_ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1index__of__instance_3_01_t_00_01type__list_3_01_ts_8_8_8_01_4_01_4.html">refl::trait::index_of_instance&lt; T, type_list&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the type in the type list that is a template instance of T, -1 if it doesn't exist.  <a href="structrefl_1_1trait_1_1index__of__instance_3_01_t_00_01type__list_3_01_ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1unique.html">refl::trait::unique&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new list containing the repeating elements in the source list only once.  <a href="structrefl_1_1trait_1_1unique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1attr_1_1usage_1_1type.html">refl::attr::usage::type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that an attribute type inheriting from this type can only be used with <a class="el" href="refl_8hpp.html#a2d90ffbabd9fc8cc17579fc33d919d71" title="Creates reflection information for a specified type.">REFL_TYPE()</a>  <a href="structrefl_1_1attr_1_1usage_1_1type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1attr_1_1usage_1_1function.html">refl::attr::usage::function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that an attribute type inheriting from this type can only be used with REFL_FUNC()  <a href="structrefl_1_1attr_1_1usage_1_1function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1attr_1_1usage_1_1field.html">refl::attr::usage::field</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that an attribute type inheriting from this type can only be used with REFL_FIELD()  <a href="structrefl_1_1attr_1_1usage_1_1field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1attr_1_1usage_1_1member.html">refl::attr::usage::member</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that an attribute type inheriting from this type can only be used with REFL_FUNC or REFL_FIELD.  <a href="structrefl_1_1attr_1_1usage_1_1member.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1attr_1_1usage_1_1any.html">refl::attr::usage::any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that an attribute type inheriting from this type can only be used with any one of REFL_TYPE, REFL_FIELD, REFL_FUNC.  <a href="structrefl_1_1attr_1_1usage_1_1any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1attr_1_1property.html">refl::attr::property</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to decorate a function that serves as a property.  <a href="structrefl_1_1attr_1_1property.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1attr_1_1debug.html">refl::attr::debug&lt; F &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to specify how a type should be displayed in debugging contexts.  <a href="structrefl_1_1attr_1_1debug.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1attr_1_1base__types.html">refl::attr::base_types&lt; Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to specify the base types of the target type.  <a href="structrefl_1_1attr_1_1base__types.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1is__member.html">refl::trait::is_member&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trait for detecting whether the type 'T' is a member descriptor.  <a href="structrefl_1_1trait_1_1is__member.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1is__field.html">refl::trait::is_field&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trait for detecting whether the type 'T' is a field descriptor.  <a href="structrefl_1_1trait_1_1is__field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1is__function.html">refl::trait::is_function&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trait for detecting whether the type 'T' is a function descriptor.  <a href="structrefl_1_1trait_1_1is__function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1is__type.html">refl::trait::is_type&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects whether the type T is a type_descriptor.  <a href="structrefl_1_1trait_1_1is__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1is__descriptor.html">refl::trait::is_descriptor&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trait for detecting whether the type 'T' is a refl-cpp descriptor.  <a href="structrefl_1_1trait_1_1is__descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1is__property.html">refl::trait::is_property&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is marked as a property.  <a href="structrefl_1_1trait_1_1is__property.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrefl_1_1descriptor_1_1member__descriptor__base.html">refl::descriptor::member_descriptor_base&lt; T, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base type for member descriptors.  <a href="classrefl_1_1descriptor_1_1member__descriptor__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrefl_1_1descriptor_1_1field__descriptor.html">refl::descriptor::field_descriptor&lt; T, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a reflected field.  <a href="classrefl_1_1descriptor_1_1field__descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrefl_1_1descriptor_1_1function__descriptor.html">refl::descriptor::function_descriptor&lt; T, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a reflected function.  <a href="classrefl_1_1descriptor_1_1function__descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrefl_1_1descriptor_1_1type__descriptor.html">refl::descriptor::type_descriptor&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a reflected type.  <a href="classrefl_1_1descriptor_1_1type__descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1runtime_1_1proxy.html">refl::runtime::proxy&lt; Derived, Target &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy object that has a static interface identical to the reflected functions and fields of the target.  <a href="structrefl_1_1runtime_1_1proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1is__proxy.html">refl::trait::is_proxy&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrefl_1_1trait_1_1is__proxy.html">refl::trait::is_proxy&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacestd"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestd.html">std</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerefl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerefl.html">refl</a></td></tr>
<tr class="memdesc:namespacerefl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The top-level refl-cpp namespace It contains a few core refl-cpp namespaces and directly exposes core classes and functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerefl_1_1util"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html">refl::util</a></td></tr>
<tr class="memdesc:namespacerefl_1_1util"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains utility types and functions for working with those types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerefl_1_1member"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1member.html">refl::member</a></td></tr>
<tr class="memdesc:namespacerefl_1_1member"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains tag types denoting the different types of reflectable members. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerefl_1_1descriptor"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html">refl::descriptor</a></td></tr>
<tr class="memdesc:namespacerefl_1_1descriptor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the basic reflection primitives as well as functions operating on those primitives. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerefl_1_1trait"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html">refl::trait</a></td></tr>
<tr class="memdesc:namespacerefl_1_1trait"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides type-level operations for refl-cpp related use-cases. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerefl_1_1attr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1attr.html">refl::attr</a></td></tr>
<tr class="memdesc:namespacerefl_1_1attr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the definitions of the built-in attributes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerefl_1_1attr_1_1usage"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1attr_1_1usage.html">refl::attr::usage</a></td></tr>
<tr class="memdesc:namespacerefl_1_1attr_1_1usage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a number of constraints applicable to refl-cpp attributes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerefl_1_1runtime"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1runtime.html">refl::runtime</a></td></tr>
<tr class="memdesc:namespacerefl_1_1runtime"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains utilities that can have runtime-overhead (like proxy, debug, invoke) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2cb939da062920a29a38dff73aaf0968"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="refl_8hpp.html#a2cb939da062920a29a38dff73aaf0968">REFL_MAKE_CONST_STRING</a>(CString)&#160;&#160;&#160;(::refl::util::detail::copy_from_unsized&lt;::refl::util::detail::strlen(CString)&gt;(CString))</td></tr>
<tr class="memdesc:a2cb939da062920a29a38dff73aaf0968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a compile-time available const char* value to a const_string&lt;N&gt;.  <a href="#a2cb939da062920a29a38dff73aaf0968">More...</a><br /></td></tr>
<tr class="separator:a2cb939da062920a29a38dff73aaf0968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc29b89a87a223da5f194d5918ba94f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="refl_8hpp.html#adc29b89a87a223da5f194d5918ba94f5">REFL_DETAIL_FORCE_EBO</a></td></tr>
<tr class="separator:adc29b89a87a223da5f194d5918ba94f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb9f0fdea25c64045020adb97393613"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="refl_8hpp.html#a3eb9f0fdea25c64045020adb97393613">REFL_DETAIL_STR_IMPL</a>(...)&#160;&#160;&#160;#__VA_ARGS__</td></tr>
<tr class="separator:a3eb9f0fdea25c64045020adb97393613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16abdfd738e4366eb239e904b90e930"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="refl_8hpp.html#ac16abdfd738e4366eb239e904b90e930">REFL_DETAIL_STR</a>(...)&#160;&#160;&#160;<a class="el" href="refl_8hpp.html#a3eb9f0fdea25c64045020adb97393613">REFL_DETAIL_STR_IMPL</a>(__VA_ARGS__)</td></tr>
<tr class="memdesc:ac16abdfd738e4366eb239e904b90e930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to stringify input separated by commas (e.g.  <a href="#ac16abdfd738e4366eb239e904b90e930">More...</a><br /></td></tr>
<tr class="separator:ac16abdfd738e4366eb239e904b90e930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6ab98a732ec684223ddfd0734f260f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="refl_8hpp.html#a4e6ab98a732ec684223ddfd0734f260f">REFL_DETAIL_GROUP</a>(...)&#160;&#160;&#160;__VA_ARGS__</td></tr>
<tr class="memdesc:a4e6ab98a732ec684223ddfd0734f260f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to group input containing commas (e.g.  <a href="#a4e6ab98a732ec684223ddfd0734f260f">More...</a><br /></td></tr>
<tr class="separator:a4e6ab98a732ec684223ddfd0734f260f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77fb25bb894a5f1f091a4a94fa67b3f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="refl_8hpp.html#ad77fb25bb894a5f1f091a4a94fa67b3f">REFL_DETAIL_ATTRIBUTES</a>(DeclType, ...)&#160;&#160;&#160;static constexpr auto attributes{ ::refl::detail::make_attributes&lt;::refl::attr::usage:: DeclType&gt;(__VA_ARGS__) }; \</td></tr>
<tr class="memdesc:ad77fb25bb894a5f1f091a4a94fa67b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands to the appropriate attributes static member variable.  <a href="#ad77fb25bb894a5f1f091a4a94fa67b3f">More...</a><br /></td></tr>
<tr class="separator:ad77fb25bb894a5f1f091a4a94fa67b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f8b46b069c2311101168d841a71b37"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="refl_8hpp.html#ac7f8b46b069c2311101168d841a71b37">REFL_DETAIL_TYPE_BODY</a>(TypeName, ...)</td></tr>
<tr class="memdesc:ac7f8b46b069c2311101168d841a71b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands to the body of a type_info__ specialization.  <a href="#ac7f8b46b069c2311101168d841a71b37">More...</a><br /></td></tr>
<tr class="separator:ac7f8b46b069c2311101168d841a71b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d90ffbabd9fc8cc17579fc33d919d71"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="refl_8hpp.html#a2d90ffbabd9fc8cc17579fc33d919d71">REFL_TYPE</a>(TypeName, ...)</td></tr>
<tr class="memdesc:a2d90ffbabd9fc8cc17579fc33d919d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates reflection information for a specified type.  <a href="#a2d90ffbabd9fc8cc17579fc33d919d71">More...</a><br /></td></tr>
<tr class="separator:a2d90ffbabd9fc8cc17579fc33d919d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832b795bfa32d4130b04e9e33635c507"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="refl_8hpp.html#a832b795bfa32d4130b04e9e33635c507">REFL_TEMPLATE</a>(TemplateDeclaration,  TypeName, ...)</td></tr>
<tr class="memdesc:a832b795bfa32d4130b04e9e33635c507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates reflection information for a specified type template.  <a href="#a832b795bfa32d4130b04e9e33635c507">More...</a><br /></td></tr>
<tr class="separator:a832b795bfa32d4130b04e9e33635c507"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae902b69e9d164cdf4b6ba5c76eed1825"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae902b69e9d164cdf4b6ba5c76eed1825"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#ae902b69e9d164cdf4b6ba5c76eed1825">refl::util::type_tag</a> = type_list&lt; T &gt;</td></tr>
<tr class="separator:ae902b69e9d164cdf4b6ba5c76eed1825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281a1cb4e19fe3ff645e48867aa8daf1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a281a1cb4e19fe3ff645e48867aa8daf1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#a281a1cb4e19fe3ff645e48867aa8daf1">refl::trait::remove_qualifiers_t</a> = typename remove_qualifiers&lt; T &gt;::type</td></tr>
<tr class="memdesc:a281a1cb4e19fe3ff645e48867aa8daf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all reference and cv-qualifiers from T.  <a href="namespacerefl_1_1trait.html#a281a1cb4e19fe3ff645e48867aa8daf1">More...</a><br /></td></tr>
<tr class="separator:a281a1cb4e19fe3ff645e48867aa8daf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fc62b3597ebdeda8040ff78c0628c3"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename TypeList &gt; </td></tr>
<tr class="memitem:a90fc62b3597ebdeda8040ff78c0628c3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#a90fc62b3597ebdeda8040ff78c0628c3">refl::trait::get_t</a> = typename get&lt; N, TypeList &gt;::type</td></tr>
<tr class="memdesc:a90fc62b3597ebdeda8040ff78c0628c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The N-th type in the provided type_list.  <a href="namespacerefl_1_1trait.html#a90fc62b3597ebdeda8040ff78c0628c3">More...</a><br /></td></tr>
<tr class="separator:a90fc62b3597ebdeda8040ff78c0628c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfe5ce0bb235343bab9b69d5115a738"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename TypeList &gt; </td></tr>
<tr class="memitem:a5cfe5ce0bb235343bab9b69d5115a738"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#a5cfe5ce0bb235343bab9b69d5115a738">refl::trait::skip_t</a> = typename skip&lt; N, TypeList &gt;::type</td></tr>
<tr class="memdesc:a5cfe5ce0bb235343bab9b69d5115a738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips the first N types in the provided type_list.  <a href="namespacerefl_1_1trait.html#a5cfe5ce0bb235343bab9b69d5115a738">More...</a><br /></td></tr>
<tr class="separator:a5cfe5ce0bb235343bab9b69d5115a738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2279db43338368acb8af9ade961a504"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2279db43338368acb8af9ade961a504"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#ae2279db43338368acb8af9ade961a504">refl::trait::as_type_list_t</a> = typename as_type_list&lt; T &gt;::type</td></tr>
<tr class="memdesc:ae2279db43338368acb8af9ade961a504"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typedef for a type_list with template type parameters equivalent to the type parameters of the provided type.  <a href="namespacerefl_1_1trait.html#ae2279db43338368acb8af9ade961a504">More...</a><br /></td></tr>
<tr class="separator:ae2279db43338368acb8af9ade961a504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7528d00a7777f3ea5bae8b6bb2814b26"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7528d00a7777f3ea5bae8b6bb2814b26"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#a7528d00a7777f3ea5bae8b6bb2814b26">refl::trait::as_tuple_t</a> = typename as_tuple&lt; T &gt;::type</td></tr>
<tr class="memdesc:a7528d00a7777f3ea5bae8b6bb2814b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typedef for a std::tuple specialization with template type parameters equivalent to the type parameters of the provided type.  <a href="namespacerefl_1_1trait.html#a7528d00a7777f3ea5bae8b6bb2814b26">More...</a><br /></td></tr>
<tr class="separator:a7528d00a7777f3ea5bae8b6bb2814b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4aae36e6ff8c6d3adb2cc91ba985e80"><td class="memTemplParams" colspan="2">template&lt;typename TypeList &gt; </td></tr>
<tr class="memitem:ab4aae36e6ff8c6d3adb2cc91ba985e80"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#ab4aae36e6ff8c6d3adb2cc91ba985e80">refl::trait::first</a> = get&lt; 0, TypeList &gt;</td></tr>
<tr class="memdesc:ab4aae36e6ff8c6d3adb2cc91ba985e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses first type in the list.  <a href="namespacerefl_1_1trait.html#ab4aae36e6ff8c6d3adb2cc91ba985e80">More...</a><br /></td></tr>
<tr class="separator:ab4aae36e6ff8c6d3adb2cc91ba985e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c142f0b5a366ee8b67c0009fa01c9d2"><td class="memTemplParams" colspan="2">template&lt;typename TypeList &gt; </td></tr>
<tr class="memitem:a8c142f0b5a366ee8b67c0009fa01c9d2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#a8c142f0b5a366ee8b67c0009fa01c9d2">refl::trait::first_t</a> = typename first&lt; TypeList &gt;::type</td></tr>
<tr class="memdesc:a8c142f0b5a366ee8b67c0009fa01c9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses last type in the list.  <a href="namespacerefl_1_1trait.html#a8c142f0b5a366ee8b67c0009fa01c9d2">More...</a><br /></td></tr>
<tr class="separator:a8c142f0b5a366ee8b67c0009fa01c9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11002f7ba1b41398115b0b102c0bacf0"><td class="memTemplParams" colspan="2">template&lt;typename TypeList &gt; </td></tr>
<tr class="memitem:a11002f7ba1b41398115b0b102c0bacf0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#a11002f7ba1b41398115b0b102c0bacf0">refl::trait::last</a> = get&lt; TypeList::size - 1, TypeList &gt;</td></tr>
<tr class="memdesc:a11002f7ba1b41398115b0b102c0bacf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses last type in the list.  <a href="namespacerefl_1_1trait.html#a11002f7ba1b41398115b0b102c0bacf0">More...</a><br /></td></tr>
<tr class="separator:a11002f7ba1b41398115b0b102c0bacf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2260f346ec8347a51e5f40c626bb0e07"><td class="memTemplParams" colspan="2">template&lt;typename TypeList &gt; </td></tr>
<tr class="memitem:a2260f346ec8347a51e5f40c626bb0e07"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#a2260f346ec8347a51e5f40c626bb0e07">refl::trait::last_t</a> = typename last&lt; TypeList &gt;::type</td></tr>
<tr class="memdesc:a2260f346ec8347a51e5f40c626bb0e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses last type in the list.  <a href="namespacerefl_1_1trait.html#a2260f346ec8347a51e5f40c626bb0e07">More...</a><br /></td></tr>
<tr class="separator:a2260f346ec8347a51e5f40c626bb0e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38acd7e400afcfd16d25d5c6ae09e65a"><td class="memTemplParams" colspan="2">template&lt;typename TypeList &gt; </td></tr>
<tr class="memitem:a38acd7e400afcfd16d25d5c6ae09e65a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#a38acd7e400afcfd16d25d5c6ae09e65a">refl::trait::tail</a> = skip&lt; 1, TypeList &gt;</td></tr>
<tr class="memdesc:a38acd7e400afcfd16d25d5c6ae09e65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all but the first element of the list.  <a href="namespacerefl_1_1trait.html#a38acd7e400afcfd16d25d5c6ae09e65a">More...</a><br /></td></tr>
<tr class="separator:a38acd7e400afcfd16d25d5c6ae09e65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96df3c32bb1b2672b5909aa9cca42cf9"><td class="memTemplParams" colspan="2">template&lt;typename TypeList &gt; </td></tr>
<tr class="memitem:a96df3c32bb1b2672b5909aa9cca42cf9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#a96df3c32bb1b2672b5909aa9cca42cf9">refl::trait::tail_t</a> = typename tail&lt; TypeList &gt;::type</td></tr>
<tr class="memdesc:a96df3c32bb1b2672b5909aa9cca42cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all but the first element of the list.  <a href="namespacerefl_1_1trait.html#a96df3c32bb1b2672b5909aa9cca42cf9">More...</a><br /></td></tr>
<tr class="separator:a96df3c32bb1b2672b5909aa9cca42cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ae2dbbb031faf63f04ffd59f476140"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename TypeList &gt; </td></tr>
<tr class="memitem:ab9ae2dbbb031faf63f04ffd59f476140"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#ab9ae2dbbb031faf63f04ffd59f476140">refl::trait::take</a> = detail::take&lt; type_list&lt;&gt;, N, TypeList &gt;</td></tr>
<tr class="memdesc:ab9ae2dbbb031faf63f04ffd59f476140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first N elements of the list.  <a href="namespacerefl_1_1trait.html#ab9ae2dbbb031faf63f04ffd59f476140">More...</a><br /></td></tr>
<tr class="separator:ab9ae2dbbb031faf63f04ffd59f476140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a7c33d3ef1f336360a68af8f14bc44"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename TypeList &gt; </td></tr>
<tr class="memitem:a08a7c33d3ef1f336360a68af8f14bc44"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#a08a7c33d3ef1f336360a68af8f14bc44">refl::trait::take_t</a> = typename take&lt; N, TypeList &gt;::type</td></tr>
<tr class="memdesc:a08a7c33d3ef1f336360a68af8f14bc44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first N elements of the list.  <a href="namespacerefl_1_1trait.html#a08a7c33d3ef1f336360a68af8f14bc44">More...</a><br /></td></tr>
<tr class="separator:a08a7c33d3ef1f336360a68af8f14bc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0240bb2e53db6d575271a9d5ebb8e85"><td class="memTemplParams" colspan="2">template&lt;typename TypeList &gt; </td></tr>
<tr class="memitem:ae0240bb2e53db6d575271a9d5ebb8e85"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#ae0240bb2e53db6d575271a9d5ebb8e85">refl::trait::init</a> = take&lt; TypeList::size - 1, TypeList &gt;</td></tr>
<tr class="memdesc:ae0240bb2e53db6d575271a9d5ebb8e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all but the last element of the list.  <a href="namespacerefl_1_1trait.html#ae0240bb2e53db6d575271a9d5ebb8e85">More...</a><br /></td></tr>
<tr class="separator:ae0240bb2e53db6d575271a9d5ebb8e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d3d356c430a7247749d0fb7fb037af"><td class="memTemplParams" colspan="2">template&lt;typename TypeList &gt; </td></tr>
<tr class="memitem:a73d3d356c430a7247749d0fb7fb037af"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#a73d3d356c430a7247749d0fb7fb037af">refl::trait::init_t</a> = typename init&lt; TypeList &gt;::type</td></tr>
<tr class="memdesc:a73d3d356c430a7247749d0fb7fb037af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all but the last element of the list.  <a href="namespacerefl_1_1trait.html#a73d3d356c430a7247749d0fb7fb037af">More...</a><br /></td></tr>
<tr class="separator:a73d3d356c430a7247749d0fb7fb037af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f78f44c53134d640b52d34ca1d9031"><td class="memTemplParams" colspan="2">template&lt;typename TypeList &gt; </td></tr>
<tr class="memitem:a07f78f44c53134d640b52d34ca1d9031"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#a07f78f44c53134d640b52d34ca1d9031">refl::trait::reverse_t</a> = typename reverse&lt; TypeList &gt;::type</td></tr>
<tr class="memdesc:a07f78f44c53134d640b52d34ca1d9031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses a list of types.  <a href="namespacerefl_1_1trait.html#a07f78f44c53134d640b52d34ca1d9031">More...</a><br /></td></tr>
<tr class="separator:a07f78f44c53134d640b52d34ca1d9031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb4edd88d696f71ecbdc82783c6ded2"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a7cb4edd88d696f71ecbdc82783c6ded2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#a7cb4edd88d696f71ecbdc82783c6ded2">refl::trait::concat_t</a> = typename concat&lt; Ts... &gt;::type</td></tr>
<tr class="memdesc:a7cb4edd88d696f71ecbdc82783c6ded2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two lists together.  <a href="namespacerefl_1_1trait.html#a7cb4edd88d696f71ecbdc82783c6ded2">More...</a><br /></td></tr>
<tr class="separator:a7cb4edd88d696f71ecbdc82783c6ded2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644910ba9f353221e50e2541a492e5cc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TypeList &gt; </td></tr>
<tr class="memitem:a644910ba9f353221e50e2541a492e5cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#a644910ba9f353221e50e2541a492e5cc">refl::trait::append_t</a> = typename append&lt; T, TypeList &gt;::type</td></tr>
<tr class="memdesc:a644910ba9f353221e50e2541a492e5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a type to the list.  <a href="namespacerefl_1_1trait.html#a644910ba9f353221e50e2541a492e5cc">More...</a><br /></td></tr>
<tr class="separator:a644910ba9f353221e50e2541a492e5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b29546446a5c8334ee733b161e6f3e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TypeList &gt; </td></tr>
<tr class="memitem:ab8b29546446a5c8334ee733b161e6f3e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#ab8b29546446a5c8334ee733b161e6f3e">refl::trait::prepend_t</a> = typename prepend&lt; T, TypeList &gt;::type</td></tr>
<tr class="memdesc:ab8b29546446a5c8334ee733b161e6f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends a type to the list.  <a href="namespacerefl_1_1trait.html#ab8b29546446a5c8334ee733b161e6f3e">More...</a><br /></td></tr>
<tr class="separator:ab8b29546446a5c8334ee733b161e6f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7c8b735416e75efa6443d59fe46493"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; typename Predicate, typename TypeList &gt; </td></tr>
<tr class="memitem:afb7c8b735416e75efa6443d59fe46493"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#afb7c8b735416e75efa6443d59fe46493">refl::trait::filter_t</a> = typename filter&lt; Predicate, TypeList &gt;::type</td></tr>
<tr class="memdesc:afb7c8b735416e75efa6443d59fe46493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a type_list according to a predicate template with a static boolean member named "value" (e.g.  <a href="namespacerefl_1_1trait.html#afb7c8b735416e75efa6443d59fe46493">More...</a><br /></td></tr>
<tr class="separator:afb7c8b735416e75efa6443d59fe46493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b580a856a2aedc8487f28a4ded1c03"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; typename Mapper, typename... Ts&gt; </td></tr>
<tr class="memitem:a27b580a856a2aedc8487f28a4ded1c03"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#a27b580a856a2aedc8487f28a4ded1c03">refl::trait::map_t</a> = typename map&lt; Mapper, Ts... &gt;::type</td></tr>
<tr class="memdesc:a27b580a856a2aedc8487f28a4ded1c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a type_list according to a predicate template with a typedef named "type" (e.g.  <a href="namespacerefl_1_1trait.html#a27b580a856a2aedc8487f28a4ded1c03">More...</a><br /></td></tr>
<tr class="separator:a27b580a856a2aedc8487f28a4ded1c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2b39ac60915978d350f5921c7e5a47"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace2b39ac60915978d350f5921c7e5a47"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#ace2b39ac60915978d350f5921c7e5a47">refl::trait::unique_t</a> = typename unique&lt; T &gt;::type</td></tr>
<tr class="memdesc:ace2b39ac60915978d350f5921c7e5a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new list containing the repeating elements in the source list only once.  <a href="namespacerefl_1_1trait.html#ace2b39ac60915978d350f5921c7e5a47">More...</a><br /></td></tr>
<tr class="separator:ace2b39ac60915978d350f5921c7e5a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c50bc8b2fa157709ed2453246d0f9a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c50bc8b2fa157709ed2453246d0f9a0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a8c50bc8b2fa157709ed2453246d0f9a0">refl::descriptor::declared_member_list</a> = typename detail::declared_member_list&lt; T &gt;::type</td></tr>
<tr class="memdesc:a8c50bc8b2fa157709ed2453246d0f9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type_list of the declared member descriptors of the target type T.  <a href="namespacerefl_1_1descriptor.html#a8c50bc8b2fa157709ed2453246d0f9a0">More...</a><br /></td></tr>
<tr class="separator:a8c50bc8b2fa157709ed2453246d0f9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b88518840c2acd134a2171795bd7c3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a50b88518840c2acd134a2171795bd7c3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a50b88518840c2acd134a2171795bd7c3">refl::descriptor::member_list</a> = typename detail::member_list&lt; T &gt;::type</td></tr>
<tr class="memdesc:a50b88518840c2acd134a2171795bd7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type_list of the declared and inherited member descriptors of the target type T.  <a href="namespacerefl_1_1descriptor.html#a50b88518840c2acd134a2171795bd7c3">More...</a><br /></td></tr>
<tr class="separator:a50b88518840c2acd134a2171795bd7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b739222556b1550c354fe00fe7ed38"><td class="memTemplParams" colspan="2">template&lt;typename FunctionDescriptor , typename... Args&gt; </td></tr>
<tr class="memitem:a99b739222556b1550c354fe00fe7ed38"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a99b739222556b1550c354fe00fe7ed38">refl::descriptor::result_type</a> = typename FunctionDescriptor::template result_type&lt; Args... &gt;</td></tr>
<tr class="memdesc:a99b739222556b1550c354fe00fe7ed38"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return type when invoking the specified descriptor using the provided argument types.  <a href="namespacerefl_1_1descriptor.html#a99b739222556b1550c354fe00fe7ed38">More...</a><br /></td></tr>
<tr class="separator:a99b739222556b1550c354fe00fe7ed38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4902f2250ab00bb4884b348893fb7641"><td class="memItemLeft" align="right" valign="top">constexpr const_string&lt; 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a4902f2250ab00bb4884b348893fb7641">refl::util::make_const_string</a> () noexcept</td></tr>
<tr class="memdesc:a4902f2250ab00bb4884b348893fb7641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty instance of const_string&lt;N&gt;  <a href="namespacerefl_1_1util.html#a4902f2250ab00bb4884b348893fb7641">More...</a><br /></td></tr>
<tr class="separator:a4902f2250ab00bb4884b348893fb7641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79e9e7d64a8511211dc01f0b74e4e17"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:ad79e9e7d64a8511211dc01f0b74e4e17"><td class="memTemplItemLeft" align="right" valign="top">constexpr const_string&lt; N - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#ad79e9e7d64a8511211dc01f0b74e4e17">refl::util::make_const_string</a> (const char(&amp;str)[N]) noexcept</td></tr>
<tr class="memdesc:ad79e9e7d64a8511211dc01f0b74e4e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of const_string&lt;N&gt;  <a href="namespacerefl_1_1util.html#ad79e9e7d64a8511211dc01f0b74e4e17">More...</a><br /></td></tr>
<tr class="separator:ad79e9e7d64a8511211dc01f0b74e4e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82b6c46a048b294ba533f7552d59bbf"><td class="memItemLeft" align="right" valign="top">constexpr const_string&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#af82b6c46a048b294ba533f7552d59bbf">refl::util::make_const_string</a> (char ch) noexcept</td></tr>
<tr class="memdesc:af82b6c46a048b294ba533f7552d59bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of const_string&lt;N&gt;  <a href="namespacerefl_1_1util.html#af82b6c46a048b294ba533f7552d59bbf">More...</a><br /></td></tr>
<tr class="separator:af82b6c46a048b294ba533f7552d59bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb53039f8928d4e4a207407a865034f0"><td class="memTemplParams" colspan="2">template&lt;size_t N, size_t M&gt; </td></tr>
<tr class="memitem:aeb53039f8928d4e4a207407a865034f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr const_string&lt; N+M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#aeb53039f8928d4e4a207407a865034f0">refl::util::operator+</a> (const const_string&lt; N &gt; &amp;a, const const_string&lt; M &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:aeb53039f8928d4e4a207407a865034f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two const_strings together.  <a href="namespacerefl_1_1util.html#aeb53039f8928d4e4a207407a865034f0">More...</a><br /></td></tr>
<tr class="separator:aeb53039f8928d4e4a207407a865034f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16ab2db12eb07f30ea39f2d94787486"><td class="memTemplParams" colspan="2">template&lt;size_t N, size_t M&gt; </td></tr>
<tr class="memitem:aa16ab2db12eb07f30ea39f2d94787486"><td class="memTemplItemLeft" align="right" valign="top">constexpr const_string&lt; N+M - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#aa16ab2db12eb07f30ea39f2d94787486">refl::util::operator+</a> (const const_string&lt; N &gt; &amp;a, const char(&amp;b)[M]) noexcept</td></tr>
<tr class="memdesc:aa16ab2db12eb07f30ea39f2d94787486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a <a class="el" href="structrefl_1_1util_1_1const__string.html" title="Represents a compile-time string.">const_string</a> with a C-style string.  <a href="namespacerefl_1_1util.html#aa16ab2db12eb07f30ea39f2d94787486">More...</a><br /></td></tr>
<tr class="separator:aa16ab2db12eb07f30ea39f2d94787486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199ad5af9e6ac09eba8eaa6a159b8209"><td class="memTemplParams" colspan="2">template&lt;size_t N, size_t M&gt; </td></tr>
<tr class="memitem:a199ad5af9e6ac09eba8eaa6a159b8209"><td class="memTemplItemLeft" align="right" valign="top">constexpr const_string&lt; N+M - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a199ad5af9e6ac09eba8eaa6a159b8209">refl::util::operator+</a> (const char(&amp;a)[N], const const_string&lt; M &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:a199ad5af9e6ac09eba8eaa6a159b8209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a C-style string with a <a class="el" href="structrefl_1_1util_1_1const__string.html" title="Represents a compile-time string.">const_string</a>.  <a href="namespacerefl_1_1util.html#a199ad5af9e6ac09eba8eaa6a159b8209">More...</a><br /></td></tr>
<tr class="separator:a199ad5af9e6ac09eba8eaa6a159b8209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b3daa04427017785fc8f2c793837af"><td class="memTemplParams" colspan="2">template&lt;size_t N, size_t M&gt; </td></tr>
<tr class="memitem:ae0b3daa04427017785fc8f2c793837af"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#ae0b3daa04427017785fc8f2c793837af">refl::util::operator==</a> (const const_string&lt; N &gt; &amp;a, const const_string&lt; M &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ae0b3daa04427017785fc8f2c793837af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two const_strings for equality.  <a href="namespacerefl_1_1util.html#ae0b3daa04427017785fc8f2c793837af">More...</a><br /></td></tr>
<tr class="separator:ae0b3daa04427017785fc8f2c793837af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44df4cd5b930d0ee80b2830097f213d7"><td class="memTemplParams" colspan="2">template&lt;size_t N, size_t M&gt; </td></tr>
<tr class="memitem:a44df4cd5b930d0ee80b2830097f213d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a44df4cd5b930d0ee80b2830097f213d7">refl::util::operator!=</a> (const const_string&lt; N &gt; &amp;a, const const_string&lt; M &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:a44df4cd5b930d0ee80b2830097f213d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two const_strings for equality.  <a href="namespacerefl_1_1util.html#a44df4cd5b930d0ee80b2830097f213d7">More...</a><br /></td></tr>
<tr class="separator:a44df4cd5b930d0ee80b2830097f213d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca109d4c938be71f874a416712ddcc6"><td class="memTemplParams" colspan="2">template&lt;size_t N, size_t M&gt; </td></tr>
<tr class="memitem:a7ca109d4c938be71f874a416712ddcc6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a7ca109d4c938be71f874a416712ddcc6">refl::util::operator==</a> (const const_string&lt; N &gt; &amp;a, const char(&amp;b)[M]) noexcept</td></tr>
<tr class="memdesc:a7ca109d4c938be71f874a416712ddcc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="structrefl_1_1util_1_1const__string.html" title="Represents a compile-time string.">const_string</a> with a C-style string for equality.  <a href="namespacerefl_1_1util.html#a7ca109d4c938be71f874a416712ddcc6">More...</a><br /></td></tr>
<tr class="separator:a7ca109d4c938be71f874a416712ddcc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28729c6245c3fec57d783ee3eb5dc6cd"><td class="memTemplParams" colspan="2">template&lt;size_t N, size_t M&gt; </td></tr>
<tr class="memitem:a28729c6245c3fec57d783ee3eb5dc6cd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a28729c6245c3fec57d783ee3eb5dc6cd">refl::util::operator!=</a> (const const_string&lt; N &gt; &amp;a, const char(&amp;b)[M]) noexcept</td></tr>
<tr class="memdesc:a28729c6245c3fec57d783ee3eb5dc6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="structrefl_1_1util_1_1const__string.html" title="Represents a compile-time string.">const_string</a> with a C-style string for equality.  <a href="namespacerefl_1_1util.html#a28729c6245c3fec57d783ee3eb5dc6cd">More...</a><br /></td></tr>
<tr class="separator:a28729c6245c3fec57d783ee3eb5dc6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d84159539d36286560bb12d8bb96dc0"><td class="memTemplParams" colspan="2">template&lt;size_t N, size_t M&gt; </td></tr>
<tr class="memitem:a1d84159539d36286560bb12d8bb96dc0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a1d84159539d36286560bb12d8bb96dc0">refl::util::operator==</a> (const char(&amp;a)[N], const const_string&lt; M &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:a1d84159539d36286560bb12d8bb96dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a C-style string with a <a class="el" href="structrefl_1_1util_1_1const__string.html" title="Represents a compile-time string.">const_string</a> for equality.  <a href="namespacerefl_1_1util.html#a1d84159539d36286560bb12d8bb96dc0">More...</a><br /></td></tr>
<tr class="separator:a1d84159539d36286560bb12d8bb96dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1d1867818badb7888668e7756c76be"><td class="memTemplParams" colspan="2">template&lt;size_t N, size_t M&gt; </td></tr>
<tr class="memitem:aad1d1867818badb7888668e7756c76be"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#aad1d1867818badb7888668e7756c76be">refl::util::operator!=</a> (const char(&amp;a)[N], const const_string&lt; M &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:aad1d1867818badb7888668e7756c76be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a C-style string with a <a class="el" href="structrefl_1_1util_1_1const__string.html" title="Represents a compile-time string.">const_string</a> for equality.  <a href="namespacerefl_1_1util.html#aad1d1867818badb7888668e7756c76be">More...</a><br /></td></tr>
<tr class="separator:aad1d1867818badb7888668e7756c76be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f75b02aaddfc2beafcbf1fadedae865"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a6f75b02aaddfc2beafcbf1fadedae865"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a6f75b02aaddfc2beafcbf1fadedae865">refl::util::operator&lt;&lt;</a> (std::ostream &amp;os, const const_string&lt; N &gt; &amp;str) noexcept</td></tr>
<tr class="separator:a6f75b02aaddfc2beafcbf1fadedae865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddab8c6121c2ff87a0694fe48e62914"><td class="memTemplParams" colspan="2">template&lt;typename T  = int, typename... Ts&gt; </td></tr>
<tr class="memitem:a9ddab8c6121c2ff87a0694fe48e62914"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a9ddab8c6121c2ff87a0694fe48e62914">refl::util::ignore</a> (Ts &amp;&amp;...) noexcept</td></tr>
<tr class="memdesc:a9ddab8c6121c2ff87a0694fe48e62914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignores all parameters.  <a href="namespacerefl_1_1util.html#a9ddab8c6121c2ff87a0694fe48e62914">More...</a><br /></td></tr>
<tr class="separator:a9ddab8c6121c2ff87a0694fe48e62914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7c97a21da83d823632fbbe65a2d722"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade7c97a21da83d823632fbbe65a2d722"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#ade7c97a21da83d823632fbbe65a2d722">refl::util::identity</a> (T &amp;&amp;t) noexcept</td></tr>
<tr class="memdesc:ade7c97a21da83d823632fbbe65a2d722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input paratemeter as-is.  <a href="namespacerefl_1_1util.html#ade7c97a21da83d823632fbbe65a2d722">More...</a><br /></td></tr>
<tr class="separator:ade7c97a21da83d823632fbbe65a2d722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab419efb086dd5940b0f032810610e2fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab419efb086dd5940b0f032810610e2fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#ab419efb086dd5940b0f032810610e2fa">refl::util::make_const</a> (const T &amp;value) noexcept</td></tr>
<tr class="memdesc:ab419efb086dd5940b0f032810610e2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds const to the input reference.  <a href="namespacerefl_1_1util.html#ab419efb086dd5940b0f032810610e2fa">More...</a><br /></td></tr>
<tr class="separator:ab419efb086dd5940b0f032810610e2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acb0bd0c244bac6c75250660d0f37bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5acb0bd0c244bac6c75250660d0f37bd"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a5acb0bd0c244bac6c75250660d0f37bd">refl::util::make_const</a> (T &amp;value) noexcept</td></tr>
<tr class="memdesc:a5acb0bd0c244bac6c75250660d0f37bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds const to the input reference.  <a href="namespacerefl_1_1util.html#a5acb0bd0c244bac6c75250660d0f37bd">More...</a><br /></td></tr>
<tr class="separator:a5acb0bd0c244bac6c75250660d0f37bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebcdc8886ed6cf62bd914eb9566882a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a6ebcdc8886ed6cf62bd914eb9566882a"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; T, sizeof...(Ts)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a6ebcdc8886ed6cf62bd914eb9566882a">refl::util::to_array</a> (const std::tuple&lt; Ts... &gt; &amp;tuple) noexcept</td></tr>
<tr class="memdesc:a6ebcdc8886ed6cf62bd914eb9566882a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an array of type 'T' from the provided tuple.  <a href="namespacerefl_1_1util.html#a6ebcdc8886ed6cf62bd914eb9566882a">More...</a><br /></td></tr>
<tr class="separator:a6ebcdc8886ed6cf62bd914eb9566882a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7db9918de2fd9e0d34caf4b6a5c1f77"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:af7db9918de2fd9e0d34caf4b6a5c1f77"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#af7db9918de2fd9e0d34caf4b6a5c1f77">refl::util::to_tuple</a> (const std::array&lt; T, N &gt; &amp;array) noexcept</td></tr>
<tr class="memdesc:af7db9918de2fd9e0d34caf4b6a5c1f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a tuple from the provided array.  <a href="namespacerefl_1_1util.html#af7db9918de2fd9e0d34caf4b6a5c1f77">More...</a><br /></td></tr>
<tr class="separator:af7db9918de2fd9e0d34caf4b6a5c1f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eef47de6755754bb8666bf61b118014"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a2eef47de6755754bb8666bf61b118014"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::tuple&lt; Ts... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a2eef47de6755754bb8666bf61b118014">refl::util::as_tuple</a> (type_list&lt; Ts... &gt;) noexcept</td></tr>
<tr class="memdesc:a2eef47de6755754bb8666bf61b118014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matching std::tuple from a <a class="el" href="structrefl_1_1util_1_1type__list.html" title="Represents a compile-time list of types provided as variadic template parameters.">type_list</a>.  <a href="namespacerefl_1_1util.html#a2eef47de6755754bb8666bf61b118014">More...</a><br /></td></tr>
<tr class="separator:a2eef47de6755754bb8666bf61b118014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fc91d7a4e148a502003f8ce4edeeef"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a17fc91d7a4e148a502003f8ce4edeeef"><td class="memTemplItemLeft" align="right" valign="top">constexpr type_list&lt; Ts... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a17fc91d7a4e148a502003f8ce4edeeef">refl::util::as_type_list</a> (const std::tuple&lt; Ts... &gt; &amp;) noexcept</td></tr>
<tr class="memdesc:a17fc91d7a4e148a502003f8ce4edeeef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matching <a class="el" href="structrefl_1_1util_1_1type__list.html" title="Represents a compile-time list of types provided as variadic template parameters.">type_list</a> from a std::tuple.  <a href="namespacerefl_1_1util.html#a17fc91d7a4e148a502003f8ce4edeeef">More...</a><br /></td></tr>
<tr class="separator:a17fc91d7a4e148a502003f8ce4edeeef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5bb478ef1cc5966e9df7c9b10b5dd3"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Ts&gt; </td></tr>
<tr class="memitem:adb5bb478ef1cc5966e9df7c9b10b5dd3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#adb5bb478ef1cc5966e9df7c9b10b5dd3">refl::util::map_to_tuple</a> (type_list&lt; Ts... &gt; list, F &amp;&amp;f)</td></tr>
<tr class="memdesc:adb5bb478ef1cc5966e9df7c9b10b5dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies function F to each type in the <a class="el" href="structrefl_1_1util_1_1type__list.html" title="Represents a compile-time list of types provided as variadic template parameters.">type_list</a>, aggregating the results in a tuple.  <a href="namespacerefl_1_1util.html#adb5bb478ef1cc5966e9df7c9b10b5dd3">More...</a><br /></td></tr>
<tr class="separator:adb5bb478ef1cc5966e9df7c9b10b5dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69ca2ba2b0353b7d3433f6a77b62902"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , typename... Ts&gt; </td></tr>
<tr class="memitem:af69ca2ba2b0353b7d3433f6a77b62902"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#af69ca2ba2b0353b7d3433f6a77b62902">refl::util::map_to_array</a> (type_list&lt; Ts... &gt; list, F &amp;&amp;f)</td></tr>
<tr class="memdesc:af69ca2ba2b0353b7d3433f6a77b62902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies function F to each type in the <a class="el" href="structrefl_1_1util_1_1type__list.html" title="Represents a compile-time list of types provided as variadic template parameters.">type_list</a>, aggregating the results in an array.  <a href="namespacerefl_1_1util.html#af69ca2ba2b0353b7d3433f6a77b62902">More...</a><br /></td></tr>
<tr class="separator:af69ca2ba2b0353b7d3433f6a77b62902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19919596cdd45c858d891c91a7826b22"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Ts&gt; </td></tr>
<tr class="memitem:a19919596cdd45c858d891c91a7826b22"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a19919596cdd45c858d891c91a7826b22">refl::util::for_each</a> (type_list&lt; Ts... &gt; list, F &amp;&amp;f)</td></tr>
<tr class="memdesc:a19919596cdd45c858d891c91a7826b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies function F to each type in the <a class="el" href="structrefl_1_1util_1_1type__list.html" title="Represents a compile-time list of types provided as variadic template parameters.">type_list</a>.  <a href="namespacerefl_1_1util.html#a19919596cdd45c858d891c91a7826b22">More...</a><br /></td></tr>
<tr class="separator:a19919596cdd45c858d891c91a7826b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e4295de1bf1350238fe01eb71d9cc1"><td class="memTemplParams" colspan="2">template&lt;typename R , typename F , typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a75e4295de1bf1350238fe01eb71d9cc1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a75e4295de1bf1350238fe01eb71d9cc1">refl::util::accumulate</a> (type_list&lt; T, Ts... &gt;, F &amp;&amp;f, R &amp;&amp;initial_value)</td></tr>
<tr class="separator:a75e4295de1bf1350238fe01eb71d9cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0417f0fd0129f2cf1ee5fa055d9c20"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Ts&gt; </td></tr>
<tr class="memitem:aea0417f0fd0129f2cf1ee5fa055d9c20"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#aea0417f0fd0129f2cf1ee5fa055d9c20">refl::util::count_if</a> (type_list&lt; Ts... &gt; list, F &amp;&amp;f)</td></tr>
<tr class="memdesc:aea0417f0fd0129f2cf1ee5fa055d9c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of times the predicate F returns true.  <a href="namespacerefl_1_1util.html#aea0417f0fd0129f2cf1ee5fa055d9c20">More...</a><br /></td></tr>
<tr class="separator:aea0417f0fd0129f2cf1ee5fa055d9c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097549e41bac7745db61442f94135c41"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Ts&gt; </td></tr>
<tr class="memitem:a097549e41bac7745db61442f94135c41"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a097549e41bac7745db61442f94135c41">refl::util::filter</a> (type_list&lt; Ts... &gt; list, F &amp;&amp;f)</td></tr>
<tr class="memdesc:a097549e41bac7745db61442f94135c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters the list according to a <em>constexpr</em> predicate.  <a href="namespacerefl_1_1util.html#a097549e41bac7745db61442f94135c41">More...</a><br /></td></tr>
<tr class="separator:a097549e41bac7745db61442f94135c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d30e9de0766352287491f18da067c0"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Ts&gt; </td></tr>
<tr class="memitem:ad1d30e9de0766352287491f18da067c0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#ad1d30e9de0766352287491f18da067c0">refl::util::find_first</a> (type_list&lt; Ts... &gt; list, F &amp;&amp;f)</td></tr>
<tr class="memdesc:ad1d30e9de0766352287491f18da067c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first instance that matches the <em>constexpr</em> predicate.  <a href="namespacerefl_1_1util.html#ad1d30e9de0766352287491f18da067c0">More...</a><br /></td></tr>
<tr class="separator:ad1d30e9de0766352287491f18da067c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6685e65aeb830a5e27dc8e4f2085ce27"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Ts&gt; </td></tr>
<tr class="memitem:a6685e65aeb830a5e27dc8e4f2085ce27"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a6685e65aeb830a5e27dc8e4f2085ce27">refl::util::find_one</a> (type_list&lt; Ts... &gt; list, F &amp;&amp;f)</td></tr>
<tr class="memdesc:a6685e65aeb830a5e27dc8e4f2085ce27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the only instance that matches the <em>constexpr</em> predicate.  <a href="namespacerefl_1_1util.html#a6685e65aeb830a5e27dc8e4f2085ce27">More...</a><br /></td></tr>
<tr class="separator:a6685e65aeb830a5e27dc8e4f2085ce27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78f978c331cb63b1450c0adbf093998"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:ab78f978c331cb63b1450c0adbf093998"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#ab78f978c331cb63b1450c0adbf093998">refl::util::contains</a> (type_list&lt; T, Ts... &gt; list, F &amp;&amp;f)</td></tr>
<tr class="memdesc:ab78f978c331cb63b1450c0adbf093998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any item in the list matches the predicate.  <a href="namespacerefl_1_1util.html#ab78f978c331cb63b1450c0adbf093998">More...</a><br /></td></tr>
<tr class="separator:ab78f978c331cb63b1450c0adbf093998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbae658ac1fcf49ae57d8a20a3818ca1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:adbae658ac1fcf49ae57d8a20a3818ca1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#adbae658ac1fcf49ae57d8a20a3818ca1">refl::util::contains</a> (type_list&lt; Ts... &gt;)</td></tr>
<tr class="memdesc:adbae658ac1fcf49ae57d8a20a3818ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="structrefl_1_1util_1_1type__list.html" title="Represents a compile-time list of types provided as variadic template parameters.">type_list</a> contains the specified type.  <a href="namespacerefl_1_1util.html#adbae658ac1fcf49ae57d8a20a3818ca1">More...</a><br /></td></tr>
<tr class="separator:adbae658ac1fcf49ae57d8a20a3818ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f02ce0f4526972a86b23ac8e98678f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:ad3f02ce0f4526972a86b23ac8e98678f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#ad3f02ce0f4526972a86b23ac8e98678f">refl::util::contains_base</a> (const std::tuple&lt; Ts... &gt; &amp;)</td></tr>
<tr class="memdesc:ad3f02ce0f4526972a86b23ac8e98678f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the tuple contains the specified type or a supertype.  <a href="namespacerefl_1_1util.html#ad3f02ce0f4526972a86b23ac8e98678f">More...</a><br /></td></tr>
<tr class="separator:ad3f02ce0f4526972a86b23ac8e98678f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d13ecc025c0703aabde8c9489deb34"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; typename T, typename... Ts&gt; </td></tr>
<tr class="memitem:a43d13ecc025c0703aabde8c9489deb34"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a43d13ecc025c0703aabde8c9489deb34">refl::util::contains_instance</a> (const std::tuple&lt; Ts... &gt; &amp;)</td></tr>
<tr class="memdesc:a43d13ecc025c0703aabde8c9489deb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the tuple contains an instance of the specified type.  <a href="namespacerefl_1_1util.html#a43d13ecc025c0703aabde8c9489deb34">More...</a><br /></td></tr>
<tr class="separator:a43d13ecc025c0703aabde8c9489deb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d05c1c63f4794ce67cbdd71f322ae6"><td class="memTemplParams" colspan="2">template&lt;typename... Ts, typename F &gt; </td></tr>
<tr class="memitem:ab5d05c1c63f4794ce67cbdd71f322ae6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#ab5d05c1c63f4794ce67cbdd71f322ae6">refl::util::apply</a> (type_list&lt; Ts... &gt;, F &amp;&amp;f)</td></tr>
<tr class="memdesc:ab5d05c1c63f4794ce67cbdd71f322ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to the elements of the <a class="el" href="structrefl_1_1util_1_1type__list.html" title="Represents a compile-time list of types provided as variadic template parameters.">type_list</a>.  <a href="namespacerefl_1_1util.html#ab5d05c1c63f4794ce67cbdd71f322ae6">More...</a><br /></td></tr>
<tr class="separator:ab5d05c1c63f4794ce67cbdd71f322ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73523bc0ad4428a1330ffa0d9b44cd8"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:ac73523bc0ad4428a1330ffa0d9b44cd8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#ac73523bc0ad4428a1330ffa0d9b44cd8">refl::util::get</a> (std::tuple&lt; Ts... &gt; &amp;ts) noexcept</td></tr>
<tr class="memdesc:ac73523bc0ad4428a1330ffa0d9b44cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A synonym for std::get&lt;N&gt;(tuple).  <a href="namespacerefl_1_1util.html#ac73523bc0ad4428a1330ffa0d9b44cd8">More...</a><br /></td></tr>
<tr class="separator:ac73523bc0ad4428a1330ffa0d9b44cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb5a84668172acdffcf557ec14061a9"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:abbb5a84668172acdffcf557ec14061a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#abbb5a84668172acdffcf557ec14061a9">refl::util::get</a> (const std::tuple&lt; Ts... &gt; &amp;ts) noexcept</td></tr>
<tr class="memdesc:abbb5a84668172acdffcf557ec14061a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A synonym for std::get&lt;N&gt;(tuple).  <a href="namespacerefl_1_1util.html#abbb5a84668172acdffcf557ec14061a9">More...</a><br /></td></tr>
<tr class="separator:abbb5a84668172acdffcf557ec14061a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe94106718ac7824623d4dc7a19411c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a6fe94106718ac7824623d4dc7a19411c"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a6fe94106718ac7824623d4dc7a19411c">refl::util::get</a> (std::tuple&lt; Ts... &gt; &amp;ts) noexcept</td></tr>
<tr class="memdesc:a6fe94106718ac7824623d4dc7a19411c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A synonym for std::get&lt;T&gt;(tuple).  <a href="namespacerefl_1_1util.html#a6fe94106718ac7824623d4dc7a19411c">More...</a><br /></td></tr>
<tr class="separator:a6fe94106718ac7824623d4dc7a19411c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794423ed7e0729c701fc4fe32ff65f75"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a794423ed7e0729c701fc4fe32ff65f75"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a794423ed7e0729c701fc4fe32ff65f75">refl::util::get</a> (const std::tuple&lt; Ts... &gt; &amp;ts) noexcept</td></tr>
<tr class="memdesc:a794423ed7e0729c701fc4fe32ff65f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">A synonym for std::get&lt;T&gt;(tuple).  <a href="namespacerefl_1_1util.html#a794423ed7e0729c701fc4fe32ff65f75">More...</a><br /></td></tr>
<tr class="separator:a794423ed7e0729c701fc4fe32ff65f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aec187f4a301c7f995ac65e17fa029a"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; typename T, typename... Ts&gt; </td></tr>
<tr class="memitem:a0aec187f4a301c7f995ac65e17fa029a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a0aec187f4a301c7f995ac65e17fa029a">refl::util::get_instance</a> (std::tuple&lt; Ts... &gt; &amp;ts) noexcept</td></tr>
<tr class="memdesc:a0aec187f4a301c7f995ac65e17fa029a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of type U, where U is a template instance of T.  <a href="namespacerefl_1_1util.html#a0aec187f4a301c7f995ac65e17fa029a">More...</a><br /></td></tr>
<tr class="separator:a0aec187f4a301c7f995ac65e17fa029a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e49f043b54cb178073ff320e77eaee6"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; typename T, typename... Ts&gt; </td></tr>
<tr class="memitem:a6e49f043b54cb178073ff320e77eaee6"><td class="memTemplItemLeft" align="right" valign="top">constexpr const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a6e49f043b54cb178073ff320e77eaee6">refl::util::get_instance</a> (const std::tuple&lt; Ts... &gt; &amp;ts) noexcept</td></tr>
<tr class="memdesc:a6e49f043b54cb178073ff320e77eaee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of type U, where U is a template instance of T.  <a href="namespacerefl_1_1util.html#a6e49f043b54cb178073ff320e77eaee6">More...</a><br /></td></tr>
<tr class="separator:a6e49f043b54cb178073ff320e77eaee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfb7f94fdcfc69947d40143b3a07d65"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a7dfb7f94fdcfc69947d40143b3a07d65"><td class="memTemplItemLeft" align="right" valign="top">constexpr type_list&lt; descriptor::type_descriptor&lt; Ts &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#a7dfb7f94fdcfc69947d40143b3a07d65">refl::util::reflect_types</a> (type_list&lt; Ts... &gt;) noexcept</td></tr>
<tr class="memdesc:a7dfb7f94fdcfc69947d40143b3a07d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="structrefl_1_1util_1_1type__list.html" title="Represents a compile-time list of types provided as variadic template parameters.">type_list</a> of types to a <a class="el" href="structrefl_1_1util_1_1type__list.html" title="Represents a compile-time list of types provided as variadic template parameters.">type_list</a> of the type_descriptors for these types.  <a href="namespacerefl_1_1util.html#a7dfb7f94fdcfc69947d40143b3a07d65">More...</a><br /></td></tr>
<tr class="separator:a7dfb7f94fdcfc69947d40143b3a07d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67a3c06ac31131661f1fb1cee670fbc"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ad67a3c06ac31131661f1fb1cee670fbc"><td class="memTemplItemLeft" align="right" valign="top">constexpr type_list&lt; Ts... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1util.html#ad67a3c06ac31131661f1fb1cee670fbc">refl::util::unreflect_types</a> (type_list&lt; descriptor::type_descriptor&lt; Ts &gt;... &gt;) noexcept</td></tr>
<tr class="memdesc:ad67a3c06ac31131661f1fb1cee670fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="structrefl_1_1util_1_1type__list.html" title="Represents a compile-time list of types provided as variadic template parameters.">type_list</a> of type_descriptors to a <a class="el" href="structrefl_1_1util_1_1type__list.html" title="Represents a compile-time list of types provided as variadic template parameters.">type_list</a> of the target types.  <a href="namespacerefl_1_1util.html#ad67a3c06ac31131661f1fb1cee670fbc">More...</a><br /></td></tr>
<tr class="separator:ad67a3c06ac31131661f1fb1cee670fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff945ef69bf77ab1725a5a8d4c1fea98"><td class="memTemplParams" colspan="2">template&lt;typename Descriptor &gt; </td></tr>
<tr class="memitem:aff945ef69bf77ab1725a5a8d4c1fea98"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#aff945ef69bf77ab1725a5a8d4c1fea98">refl::descriptor::get_name</a> (Descriptor d) noexcept</td></tr>
<tr class="memdesc:aff945ef69bf77ab1725a5a8d4c1fea98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the full name of the descriptor.  <a href="namespacerefl_1_1descriptor.html#aff945ef69bf77ab1725a5a8d4c1fea98">More...</a><br /></td></tr>
<tr class="separator:aff945ef69bf77ab1725a5a8d4c1fea98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268faca3e6a1845928f583abe5ef877e"><td class="memTemplParams" colspan="2">template&lt;typename Descriptor &gt; </td></tr>
<tr class="memitem:a268faca3e6a1845928f583abe5ef877e"><td class="memTemplItemLeft" align="right" valign="top">constexpr const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a268faca3e6a1845928f583abe5ef877e">refl::descriptor::get_attributes</a> (Descriptor d) noexcept</td></tr>
<tr class="memdesc:a268faca3e6a1845928f583abe5ef877e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the descriptor's attribute tuple.  <a href="namespacerefl_1_1descriptor.html#a268faca3e6a1845928f583abe5ef877e">More...</a><br /></td></tr>
<tr class="separator:a268faca3e6a1845928f583abe5ef877e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ed2ffb6772717a47f526da332c45c8"><td class="memTemplParams" colspan="2">template&lt;typename Descriptor &gt; </td></tr>
<tr class="memitem:a84ed2ffb6772717a47f526da332c45c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a84ed2ffb6772717a47f526da332c45c8">refl::descriptor::get_attribute_types</a> (Descriptor d) noexcept</td></tr>
<tr class="memdesc:a84ed2ffb6772717a47f526da332c45c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type_list of the descriptor's attribute types.  <a href="namespacerefl_1_1descriptor.html#a84ed2ffb6772717a47f526da332c45c8">More...</a><br /></td></tr>
<tr class="separator:a84ed2ffb6772717a47f526da332c45c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb250d284ee439d4307299a9cb22498c"><td class="memTemplParams" colspan="2">template&lt;typename TypeDescriptor &gt; </td></tr>
<tr class="memitem:acb250d284ee439d4307299a9cb22498c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#acb250d284ee439d4307299a9cb22498c">refl::descriptor::get_declared_base_types</a> (TypeDescriptor t) noexcept</td></tr>
<tr class="memdesc:acb250d284ee439d4307299a9cb22498c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type_list of the declared base types of the type.  <a href="namespacerefl_1_1descriptor.html#acb250d284ee439d4307299a9cb22498c">More...</a><br /></td></tr>
<tr class="separator:acb250d284ee439d4307299a9cb22498c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc445cfd9be739891c2b6731047cf144"><td class="memTemplParams" colspan="2">template&lt;typename TypeDescriptor &gt; </td></tr>
<tr class="memitem:afc445cfd9be739891c2b6731047cf144"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#afc445cfd9be739891c2b6731047cf144">refl::descriptor::get_base_types</a> (TypeDescriptor t) noexcept</td></tr>
<tr class="memdesc:afc445cfd9be739891c2b6731047cf144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type_list of the declared and inherited base types of the type.  <a href="namespacerefl_1_1descriptor.html#afc445cfd9be739891c2b6731047cf144">More...</a><br /></td></tr>
<tr class="separator:afc445cfd9be739891c2b6731047cf144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af716224744f34050b6b43a95251f750c"><td class="memTemplParams" colspan="2">template&lt;typename TypeDescriptor &gt; </td></tr>
<tr class="memitem:af716224744f34050b6b43a95251f750c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#af716224744f34050b6b43a95251f750c">refl::descriptor::get_declared_members</a> (TypeDescriptor t) noexcept</td></tr>
<tr class="memdesc:af716224744f34050b6b43a95251f750c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type_list of the declared members of the type.  <a href="namespacerefl_1_1descriptor.html#af716224744f34050b6b43a95251f750c">More...</a><br /></td></tr>
<tr class="separator:af716224744f34050b6b43a95251f750c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60741d56b2c28157b3588b7348256b7"><td class="memTemplParams" colspan="2">template&lt;typename TypeDescriptor &gt; </td></tr>
<tr class="memitem:ad60741d56b2c28157b3588b7348256b7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#ad60741d56b2c28157b3588b7348256b7">refl::descriptor::get_members</a> (TypeDescriptor t) noexcept</td></tr>
<tr class="memdesc:ad60741d56b2c28157b3588b7348256b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type_list of the declared and inherited members of the type.  <a href="namespacerefl_1_1descriptor.html#ad60741d56b2c28157b3588b7348256b7">More...</a><br /></td></tr>
<tr class="separator:ad60741d56b2c28157b3588b7348256b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe87e9035c9416033b3514aa094bc0fd"><td class="memTemplParams" colspan="2">template&lt;typename MemberDescriptor &gt; </td></tr>
<tr class="memitem:afe87e9035c9416033b3514aa094bc0fd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#afe87e9035c9416033b3514aa094bc0fd">refl::descriptor::get_declarator</a> (MemberDescriptor d) noexcept</td></tr>
<tr class="memdesc:afe87e9035c9416033b3514aa094bc0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classrefl_1_1descriptor_1_1type__descriptor.html" title="Represents a reflected type.">type_descriptor</a> of declaring type of the member.  <a href="namespacerefl_1_1descriptor.html#afe87e9035c9416033b3514aa094bc0fd">More...</a><br /></td></tr>
<tr class="separator:afe87e9035c9416033b3514aa094bc0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e6a5698114443414d43d3b4ae1c50c"><td class="memTemplParams" colspan="2">template&lt;typename MemberDescriptor &gt; </td></tr>
<tr class="memitem:a75e6a5698114443414d43d3b4ae1c50c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a75e6a5698114443414d43d3b4ae1c50c">refl::descriptor::get_pointer</a> (MemberDescriptor d) noexcept</td></tr>
<tr class="memdesc:a75e6a5698114443414d43d3b4ae1c50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the reflected field/function.  <a href="namespacerefl_1_1descriptor.html#a75e6a5698114443414d43d3b4ae1c50c">More...</a><br /></td></tr>
<tr class="separator:a75e6a5698114443414d43d3b4ae1c50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17264f6fe5ef2e6f10a67304cb40e83"><td class="memTemplParams" colspan="2">template&lt;typename MemberDescriptor , typename... Args&gt; </td></tr>
<tr class="memitem:ab17264f6fe5ef2e6f10a67304cb40e83"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#ab17264f6fe5ef2e6f10a67304cb40e83">refl::descriptor::invoke</a> (MemberDescriptor d, Args &amp;&amp;... args) noexcept -&gt; decltype(d(std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:ab17264f6fe5ef2e6f10a67304cb40e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the member with the specified arguments.  <a href="namespacerefl_1_1descriptor.html#ab17264f6fe5ef2e6f10a67304cb40e83">More...</a><br /></td></tr>
<tr class="separator:ab17264f6fe5ef2e6f10a67304cb40e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a133a31fb133920609bba17fad68b2"><td class="memTemplParams" colspan="2">template&lt;typename FieldDescriptor &gt; </td></tr>
<tr class="memitem:a19a133a31fb133920609bba17fad68b2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a19a133a31fb133920609bba17fad68b2">refl::descriptor::is_static</a> (FieldDescriptor d) noexcept</td></tr>
<tr class="memdesc:a19a133a31fb133920609bba17fad68b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the field is declared as static.  <a href="namespacerefl_1_1descriptor.html#a19a133a31fb133920609bba17fad68b2">More...</a><br /></td></tr>
<tr class="separator:a19a133a31fb133920609bba17fad68b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6127ab327b1e8f31062e9d0e2440a757"><td class="memTemplParams" colspan="2">template&lt;typename FieldDescriptor &gt; </td></tr>
<tr class="memitem:a6127ab327b1e8f31062e9d0e2440a757"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a6127ab327b1e8f31062e9d0e2440a757">refl::descriptor::is_const</a> (FieldDescriptor d) noexcept</td></tr>
<tr class="memdesc:a6127ab327b1e8f31062e9d0e2440a757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the value type of the field is const-qualified.  <a href="namespacerefl_1_1descriptor.html#a6127ab327b1e8f31062e9d0e2440a757">More...</a><br /></td></tr>
<tr class="separator:a6127ab327b1e8f31062e9d0e2440a757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2afa6e939c641de9a9f184388341da"><td class="memTemplParams" colspan="2">template&lt;typename FunctionDescriptor &gt; </td></tr>
<tr class="memitem:a8d2afa6e939c641de9a9f184388341da"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a8d2afa6e939c641de9a9f184388341da">refl::descriptor::is_resolved</a> (FunctionDescriptor d) noexcept</td></tr>
<tr class="memdesc:a8d2afa6e939c641de9a9f184388341da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the function pointer was automatically resolved.  <a href="namespacerefl_1_1descriptor.html#a8d2afa6e939c641de9a9f184388341da">More...</a><br /></td></tr>
<tr class="separator:a8d2afa6e939c641de9a9f184388341da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d6702622d06d0e2f5792f903626790"><td class="memTemplParams" colspan="2">template&lt;typename Pointer , typename FunctionDescriptor &gt; </td></tr>
<tr class="memitem:ad3d6702622d06d0e2f5792f903626790"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#ad3d6702622d06d0e2f5792f903626790">refl::descriptor::can_resolve</a> (FunctionDescriptor d) noexcept</td></tr>
<tr class="memdesc:ad3d6702622d06d0e2f5792f903626790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the function pointer can be resolved as a pointer of the specified type.  <a href="namespacerefl_1_1descriptor.html#ad3d6702622d06d0e2f5792f903626790">More...</a><br /></td></tr>
<tr class="separator:ad3d6702622d06d0e2f5792f903626790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0a7b34d1892fffb8355aaeff29c750"><td class="memTemplParams" colspan="2">template&lt;typename Pointer , typename FunctionDescriptor &gt; </td></tr>
<tr class="memitem:a1a0a7b34d1892fffb8355aaeff29c750"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a1a0a7b34d1892fffb8355aaeff29c750">refl::descriptor::resolve</a> (FunctionDescriptor d) noexcept</td></tr>
<tr class="memdesc:a1a0a7b34d1892fffb8355aaeff29c750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves the function pointer as a pointer of the specified type.  <a href="namespacerefl_1_1descriptor.html#a1a0a7b34d1892fffb8355aaeff29c750">More...</a><br /></td></tr>
<tr class="separator:a1a0a7b34d1892fffb8355aaeff29c750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1454a5c8702f245ceafaa9731026f7fe"><td class="memTemplParams" colspan="2">template&lt;typename Descriptor &gt; </td></tr>
<tr class="memitem:a1454a5c8702f245ceafaa9731026f7fe"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a1454a5c8702f245ceafaa9731026f7fe">refl::descriptor::is_field</a> (Descriptor) noexcept</td></tr>
<tr class="memdesc:a1454a5c8702f245ceafaa9731026f7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a field descriptor.  <a href="namespacerefl_1_1descriptor.html#a1454a5c8702f245ceafaa9731026f7fe">More...</a><br /></td></tr>
<tr class="separator:a1454a5c8702f245ceafaa9731026f7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76608e349f1f11d8e7eb5ccb759806a6"><td class="memTemplParams" colspan="2">template&lt;typename Descriptor &gt; </td></tr>
<tr class="memitem:a76608e349f1f11d8e7eb5ccb759806a6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a76608e349f1f11d8e7eb5ccb759806a6">refl::descriptor::is_function</a> (Descriptor) noexcept</td></tr>
<tr class="memdesc:a76608e349f1f11d8e7eb5ccb759806a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a function descriptor.  <a href="namespacerefl_1_1descriptor.html#a76608e349f1f11d8e7eb5ccb759806a6">More...</a><br /></td></tr>
<tr class="separator:a76608e349f1f11d8e7eb5ccb759806a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2665e32dba32044036fa66303c12aa"><td class="memTemplParams" colspan="2">template&lt;typename Descriptor &gt; </td></tr>
<tr class="memitem:abe2665e32dba32044036fa66303c12aa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#abe2665e32dba32044036fa66303c12aa">refl::descriptor::is_type</a> (Descriptor) noexcept</td></tr>
<tr class="memdesc:abe2665e32dba32044036fa66303c12aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a type descriptor.  <a href="namespacerefl_1_1descriptor.html#abe2665e32dba32044036fa66303c12aa">More...</a><br /></td></tr>
<tr class="separator:abe2665e32dba32044036fa66303c12aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024d98e2fa7e18a1d7ece243549cde68"><td class="memTemplParams" colspan="2">template&lt;typename A , typename Descriptor &gt; </td></tr>
<tr class="memitem:a024d98e2fa7e18a1d7ece243549cde68"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a024d98e2fa7e18a1d7ece243549cde68">refl::descriptor::has_attribute</a> (Descriptor) noexcept</td></tr>
<tr class="memdesc:a024d98e2fa7e18a1d7ece243549cde68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T has an attribute of type A.  <a href="namespacerefl_1_1descriptor.html#a024d98e2fa7e18a1d7ece243549cde68">More...</a><br /></td></tr>
<tr class="separator:a024d98e2fa7e18a1d7ece243549cde68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58bf4f2ac8fe5f09cb185a9e16ade53c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename Descriptor &gt; </td></tr>
<tr class="memitem:a58bf4f2ac8fe5f09cb185a9e16ade53c"><td class="memTemplItemLeft" align="right" valign="top">constexpr const A &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a58bf4f2ac8fe5f09cb185a9e16ade53c">refl::descriptor::get_attribute</a> (Descriptor d) noexcept</td></tr>
<tr class="memdesc:a58bf4f2ac8fe5f09cb185a9e16ade53c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the attribute A on T.  <a href="namespacerefl_1_1descriptor.html#a58bf4f2ac8fe5f09cb185a9e16ade53c">More...</a><br /></td></tr>
<tr class="separator:a58bf4f2ac8fe5f09cb185a9e16ade53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14abdc2a7e7e1f85647a6e79d9ae80dc"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; typename A, typename Descriptor &gt; </td></tr>
<tr class="memitem:a14abdc2a7e7e1f85647a6e79d9ae80dc"><td class="memTemplItemLeft" align="right" valign="top">constexpr const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a14abdc2a7e7e1f85647a6e79d9ae80dc">refl::descriptor::get_attribute</a> (Descriptor d) noexcept</td></tr>
<tr class="memdesc:a14abdc2a7e7e1f85647a6e79d9ae80dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the attribute A on T.  <a href="namespacerefl_1_1descriptor.html#a14abdc2a7e7e1f85647a6e79d9ae80dc">More...</a><br /></td></tr>
<tr class="separator:a14abdc2a7e7e1f85647a6e79d9ae80dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288a833843be97b2d80b51b1de886f99"><td class="memTemplParams" colspan="2">template&lt;typename MemberDescriptor &gt; </td></tr>
<tr class="memitem:a288a833843be97b2d80b51b1de886f99"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a288a833843be97b2d80b51b1de886f99">refl::descriptor::is_property</a> (MemberDescriptor d) noexcept</td></tr>
<tr class="memdesc:a288a833843be97b2d80b51b1de886f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a member descriptor marked with the property attribute.  <a href="namespacerefl_1_1descriptor.html#a288a833843be97b2d80b51b1de886f99">More...</a><br /></td></tr>
<tr class="separator:a288a833843be97b2d80b51b1de886f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb1bb89c2469071ced6551ca3b9b8fd"><td class="memTemplParams" colspan="2">template&lt;typename FunctionDescriptor &gt; </td></tr>
<tr class="memitem:aadb1bb89c2469071ced6551ca3b9b8fd"><td class="memTemplItemLeft" align="right" valign="top">constexpr attr::property&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#aadb1bb89c2469071ced6551ca3b9b8fd">refl::descriptor::get_property</a> (FunctionDescriptor d) noexcept</td></tr>
<tr class="memdesc:aadb1bb89c2469071ced6551ca3b9b8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the property attribute.  <a href="namespacerefl_1_1descriptor.html#aadb1bb89c2469071ced6551ca3b9b8fd">More...</a><br /></td></tr>
<tr class="separator:aadb1bb89c2469071ced6551ca3b9b8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68bedab33d684ee5ee4ead24c5586ab"><td class="memTemplParams" colspan="2">template&lt;typename MemberDescriptor &gt; </td></tr>
<tr class="memitem:aa68bedab33d684ee5ee4ead24c5586ab"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#aa68bedab33d684ee5ee4ead24c5586ab">refl::descriptor::is_readable</a> (MemberDescriptor) noexcept</td></tr>
<tr class="memdesc:aa68bedab33d684ee5ee4ead24c5586ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if T is a 0-arg const-qualified member function with a property attribute or a field.  <a href="namespacerefl_1_1descriptor.html#aa68bedab33d684ee5ee4ead24c5586ab">More...</a><br /></td></tr>
<tr class="separator:aa68bedab33d684ee5ee4ead24c5586ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925e8cb99d6199fe03edeb5109958f8d"><td class="memTemplParams" colspan="2">template&lt;typename MemberDescriptor &gt; </td></tr>
<tr class="memitem:a925e8cb99d6199fe03edeb5109958f8d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a925e8cb99d6199fe03edeb5109958f8d">refl::descriptor::is_writable</a> (MemberDescriptor) noexcept</td></tr>
<tr class="memdesc:a925e8cb99d6199fe03edeb5109958f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if T is a 1-arg non-const-qualified member function with a property attribute or a non-const field.  <a href="namespacerefl_1_1descriptor.html#a925e8cb99d6199fe03edeb5109958f8d">More...</a><br /></td></tr>
<tr class="separator:a925e8cb99d6199fe03edeb5109958f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00126ab409dbc1a5445d37832876fe2"><td class="memTemplParams" colspan="2">template&lt;typename TypeDescriptor &gt; </td></tr>
<tr class="memitem:ac00126ab409dbc1a5445d37832876fe2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#ac00126ab409dbc1a5445d37832876fe2">refl::descriptor::has_bases</a> (TypeDescriptor t) noexcept</td></tr>
<tr class="memdesc:ac00126ab409dbc1a5445d37832876fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type has a bases attribute.  <a href="namespacerefl_1_1descriptor.html#ac00126ab409dbc1a5445d37832876fe2">More...</a><br /></td></tr>
<tr class="separator:ac00126ab409dbc1a5445d37832876fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725c882cfae058b70d50517fe134a938"><td class="memTemplParams" colspan="2">template&lt;typename TypeDescriptor &gt; </td></tr>
<tr class="memitem:a725c882cfae058b70d50517fe134a938"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a725c882cfae058b70d50517fe134a938">refl::descriptor::get_bases</a> (TypeDescriptor t) noexcept</td></tr>
<tr class="memdesc:a725c882cfae058b70d50517fe134a938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of the type_descriptor&lt;T&gt;s of the base types of the target, as specified by the bases&lt;A, B, ...&gt; attribute.  <a href="namespacerefl_1_1descriptor.html#a725c882cfae058b70d50517fe134a938">More...</a><br /></td></tr>
<tr class="separator:a725c882cfae058b70d50517fe134a938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5621e8b981bfb910f027fb720320f977"><td class="memTemplParams" colspan="2">template&lt;typename TypeDescriptor &gt; </td></tr>
<tr class="memitem:a5621e8b981bfb910f027fb720320f977"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a5621e8b981bfb910f027fb720320f977">refl::descriptor::get_simple_name</a> (TypeDescriptor t)</td></tr>
<tr class="memdesc:a5621e8b981bfb910f027fb720320f977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unqualified name of the type, discarding the namespace and typenames (if a template type).  <a href="namespacerefl_1_1descriptor.html#a5621e8b981bfb910f027fb720320f977">More...</a><br /></td></tr>
<tr class="separator:a5621e8b981bfb910f027fb720320f977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18162a39182126fc2345f2fe3e5b058"><td class="memTemplParams" colspan="2">template&lt;typename MemberDescriptor &gt; </td></tr>
<tr class="memitem:aa18162a39182126fc2345f2fe3e5b058"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#aa18162a39182126fc2345f2fe3e5b058">refl::descriptor::get_debug_name_const</a> (MemberDescriptor d)</td></tr>
<tr class="memdesc:aa18162a39182126fc2345f2fe3e5b058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug name of T (In the form of 'declaring_type::member_name') as a const_string.  <a href="namespacerefl_1_1descriptor.html#aa18162a39182126fc2345f2fe3e5b058">More...</a><br /></td></tr>
<tr class="separator:aa18162a39182126fc2345f2fe3e5b058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af888ff528516ddbb240168f59e2427e4"><td class="memTemplParams" colspan="2">template&lt;typename MemberDescriptor &gt; </td></tr>
<tr class="memitem:af888ff528516ddbb240168f59e2427e4"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#af888ff528516ddbb240168f59e2427e4">refl::descriptor::get_debug_name</a> (MemberDescriptor d)</td></tr>
<tr class="memdesc:af888ff528516ddbb240168f59e2427e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug name of T.  <a href="namespacerefl_1_1descriptor.html#af888ff528516ddbb240168f59e2427e4">More...</a><br /></td></tr>
<tr class="separator:af888ff528516ddbb240168f59e2427e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f021ce9c4ef95ab4313aefb8f4f3588"><td class="memTemplParams" colspan="2">template&lt;typename Descriptor &gt; </td></tr>
<tr class="memitem:a9f021ce9c4ef95ab4313aefb8f4f3588"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a9f021ce9c4ef95ab4313aefb8f4f3588">refl::descriptor::get_display_name</a> (Descriptor d) noexcept</td></tr>
<tr class="memdesc:a9f021ce9c4ef95ab4313aefb8f4f3588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the display name of T.  <a href="namespacerefl_1_1descriptor.html#a9f021ce9c4ef95ab4313aefb8f4f3588">More...</a><br /></td></tr>
<tr class="separator:a9f021ce9c4ef95ab4313aefb8f4f3588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb65ca47183b468df2b8429dc5dea61"><td class="memTemplParams" colspan="2">template&lt;typename Descriptor &gt; </td></tr>
<tr class="memitem:a7cb65ca47183b468df2b8429dc5dea61"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a7cb65ca47183b468df2b8429dc5dea61">refl::descriptor::get_display_name_const</a> (Descriptor d) noexcept</td></tr>
<tr class="memdesc:a7cb65ca47183b468df2b8429dc5dea61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the display name of T as a const_string&lt;N&gt;.  <a href="namespacerefl_1_1descriptor.html#a7cb65ca47183b468df2b8429dc5dea61">More...</a><br /></td></tr>
<tr class="separator:a7cb65ca47183b468df2b8429dc5dea61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435c850ae43e86f333a9c19b0f24580c"><td class="memTemplParams" colspan="2">template&lt;typename ReadableMember &gt; </td></tr>
<tr class="memitem:a435c850ae43e86f333a9c19b0f24580c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a435c850ae43e86f333a9c19b0f24580c">refl::descriptor::has_writer</a> (ReadableMember member)</td></tr>
<tr class="memdesc:a435c850ae43e86f333a9c19b0f24580c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there exists a member that has the same display name as the one provied and is writable.  <a href="namespacerefl_1_1descriptor.html#a435c850ae43e86f333a9c19b0f24580c">More...</a><br /></td></tr>
<tr class="separator:a435c850ae43e86f333a9c19b0f24580c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9505e8a9ccb0bf419927d27f3ff20f3"><td class="memTemplParams" colspan="2">template&lt;typename WritableMember &gt; </td></tr>
<tr class="memitem:ac9505e8a9ccb0bf419927d27f3ff20f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#ac9505e8a9ccb0bf419927d27f3ff20f3">refl::descriptor::has_reader</a> (WritableMember member)</td></tr>
<tr class="memdesc:ac9505e8a9ccb0bf419927d27f3ff20f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there exists a member that has the same display name as the one provied and is readable.  <a href="namespacerefl_1_1descriptor.html#ac9505e8a9ccb0bf419927d27f3ff20f3">More...</a><br /></td></tr>
<tr class="separator:ac9505e8a9ccb0bf419927d27f3ff20f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cc337624b45bd2d5f9b27d6811fafd"><td class="memTemplParams" colspan="2">template&lt;typename ReadableMember &gt; </td></tr>
<tr class="memitem:ad4cc337624b45bd2d5f9b27d6811fafd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#ad4cc337624b45bd2d5f9b27d6811fafd">refl::descriptor::get_writer</a> (ReadableMember member)</td></tr>
<tr class="memdesc:ad4cc337624b45bd2d5f9b27d6811fafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a member that has the same display name as the one provied and is writable.  <a href="namespacerefl_1_1descriptor.html#ad4cc337624b45bd2d5f9b27d6811fafd">More...</a><br /></td></tr>
<tr class="separator:ad4cc337624b45bd2d5f9b27d6811fafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3690f579517cc28e9d2eacb3d095fdbb"><td class="memTemplParams" colspan="2">template&lt;typename WritableMember &gt; </td></tr>
<tr class="memitem:a3690f579517cc28e9d2eacb3d095fdbb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a3690f579517cc28e9d2eacb3d095fdbb">refl::descriptor::get_reader</a> (WritableMember member)</td></tr>
<tr class="memdesc:a3690f579517cc28e9d2eacb3d095fdbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a member that has the same display name as the one provied and is readable.  <a href="namespacerefl_1_1descriptor.html#a3690f579517cc28e9d2eacb3d095fdbb">More...</a><br /></td></tr>
<tr class="separator:a3690f579517cc28e9d2eacb3d095fdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e0f11daf60216683e454102d247300"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a12e0f11daf60216683e454102d247300"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl.html#a12e0f11daf60216683e454102d247300">refl::is_reflectable</a> () noexcept</td></tr>
<tr class="memdesc:a12e0f11daf60216683e454102d247300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the type T is reflectable.  <a href="namespacerefl.html#a12e0f11daf60216683e454102d247300">More...</a><br /></td></tr>
<tr class="separator:a12e0f11daf60216683e454102d247300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988e607c536b5e75698d9f086909246c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a988e607c536b5e75698d9f086909246c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl.html#a988e607c536b5e75698d9f086909246c">refl::is_reflectable</a> (const T &amp;) noexcept</td></tr>
<tr class="memdesc:a988e607c536b5e75698d9f086909246c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the non-qualified type T is reflectable.  <a href="namespacerefl.html#a988e607c536b5e75698d9f086909246c">More...</a><br /></td></tr>
<tr class="separator:a988e607c536b5e75698d9f086909246c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95fbc2d63a7db5ce4d8a4dcca3d637e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae95fbc2d63a7db5ce4d8a4dcca3d637e"><td class="memTemplItemLeft" align="right" valign="top">constexpr type_descriptor&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl.html#ae95fbc2d63a7db5ce4d8a4dcca3d637e">refl::reflect</a> () noexcept</td></tr>
<tr class="memdesc:ae95fbc2d63a7db5ce4d8a4dcca3d637e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type descriptor for the type T.  <a href="namespacerefl.html#ae95fbc2d63a7db5ce4d8a4dcca3d637e">More...</a><br /></td></tr>
<tr class="separator:ae95fbc2d63a7db5ce4d8a4dcca3d637e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a70ee908d690769979f0aa9f57eb3e9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a70ee908d690769979f0aa9f57eb3e9"><td class="memTemplItemLeft" align="right" valign="top">constexpr type_descriptor&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl.html#a5a70ee908d690769979f0aa9f57eb3e9">refl::reflect</a> (const T &amp;) noexcept</td></tr>
<tr class="memdesc:a5a70ee908d690769979f0aa9f57eb3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type descriptor for the non-qualified type T.  <a href="namespacerefl.html#a5a70ee908d690769979f0aa9f57eb3e9">More...</a><br /></td></tr>
<tr class="separator:a5a70ee908d690769979f0aa9f57eb3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e1996b05966eac4f282b6656169d6a"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename T &gt; </td></tr>
<tr class="memitem:a06e1996b05966eac4f282b6656169d6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1runtime.html#a06e1996b05966eac4f282b6656169d6a">refl::runtime::debug</a> (std::basic_ostream&lt; CharT &gt; &amp;os, const T &amp;value, bool compact=false)</td></tr>
<tr class="separator:a06e1996b05966eac4f282b6656169d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ba25f8e5e09bd30234c28839ec6d7c"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename T &gt; </td></tr>
<tr class="memitem:ad3ba25f8e5e09bd30234c28839ec6d7c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1runtime.html#ad3ba25f8e5e09bd30234c28839ec6d7c">refl::runtime::debug</a> (std::basic_ostream&lt; CharT &gt; &amp;os, const T &amp;value, [[maybe_unused]] bool compact)</td></tr>
<tr class="memdesc:ad3ba25f8e5e09bd30234c28839ec6d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the debug representation of value to the given std::ostream.  <a href="namespacerefl_1_1runtime.html#ad3ba25f8e5e09bd30234c28839ec6d7c">More...</a><br /></td></tr>
<tr class="separator:ad3ba25f8e5e09bd30234c28839ec6d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63a0044074e3c5a78f8e8a2662783aa"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename... Ts&gt; </td></tr>
<tr class="memitem:ab63a0044074e3c5a78f8e8a2662783aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1runtime.html#ab63a0044074e3c5a78f8e8a2662783aa">refl::runtime::debug_all</a> (std::basic_ostream&lt; CharT &gt; &amp;os, const Ts &amp;... values)</td></tr>
<tr class="memdesc:ab63a0044074e3c5a78f8e8a2662783aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the compact debug representation of the provided values to the given std::ostream.  <a href="namespacerefl_1_1runtime.html#ab63a0044074e3c5a78f8e8a2662783aa">More...</a><br /></td></tr>
<tr class="separator:ab63a0044074e3c5a78f8e8a2662783aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add62a33c7bf6980c9e6d6e5a8977540e"><td class="memTemplParams" colspan="2">template&lt;typename CharT  = char, typename T &gt; </td></tr>
<tr class="memitem:add62a33c7bf6980c9e6d6e5a8977540e"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; CharT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1runtime.html#add62a33c7bf6980c9e6d6e5a8977540e">refl::runtime::debug_str</a> (const T &amp;value, bool compact=false)</td></tr>
<tr class="memdesc:add62a33c7bf6980c9e6d6e5a8977540e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the debug representation of the provided value to an std::string and returns it.  <a href="namespacerefl_1_1runtime.html#add62a33c7bf6980c9e6d6e5a8977540e">More...</a><br /></td></tr>
<tr class="separator:add62a33c7bf6980c9e6d6e5a8977540e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bcab18d57d392f64fea2a46717d47b"><td class="memTemplParams" colspan="2">template&lt;typename CharT  = char, typename... Ts&gt; </td></tr>
<tr class="memitem:a57bcab18d57d392f64fea2a46717d47b"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; CharT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1runtime.html#a57bcab18d57d392f64fea2a46717d47b">refl::runtime::debug_all_str</a> (const Ts &amp;... values)</td></tr>
<tr class="memdesc:a57bcab18d57d392f64fea2a46717d47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the compact debug representation of the provided values to an std::string and returns it.  <a href="namespacerefl_1_1runtime.html#a57bcab18d57d392f64fea2a46717d47b">More...</a><br /></td></tr>
<tr class="separator:a57bcab18d57d392f64fea2a46717d47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0831da0114fa506579224ce219d0ab50"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a0831da0114fa506579224ce219d0ab50"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1runtime.html#a0831da0114fa506579224ce219d0ab50">refl::runtime::invoke</a> (T &amp;&amp;target, const char *name, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0831da0114fa506579224ce219d0ab50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the specified member with the provided arguments.  <a href="namespacerefl_1_1runtime.html#a0831da0114fa506579224ce219d0ab50">More...</a><br /></td></tr>
<tr class="separator:a0831da0114fa506579224ce219d0ab50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9c31605a5aef99561286104c9a3da628"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9c31605a5aef99561286104c9a3da628"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1trait.html#a9c31605a5aef99561286104c9a3da628">refl::trait::is_type_v</a> { is_type&lt;T&gt;::value }</td></tr>
<tr class="memdesc:a9c31605a5aef99561286104c9a3da628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects whether the type T is a type_descriptor.  <a href="namespacerefl_1_1trait.html#a9c31605a5aef99561286104c9a3da628">More...</a><br /></td></tr>
<tr class="separator:a9c31605a5aef99561286104c9a3da628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ea7c32cad8eb5cc0512f774a65da04"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename Target &gt; </td></tr>
<tr class="memitem:a10ea7c32cad8eb5cc0512f774a65da04"><td class="memTemplItemLeft" align="right" valign="top">struct <a class="el" href="refl_8hpp.html#adc29b89a87a223da5f194d5918ba94f5">REFL_DETAIL_FORCE_EBO</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1runtime.html#a10ea7c32cad8eb5cc0512f774a65da04">refl::runtime::proxy</a></td></tr>
<tr class="separator:a10ea7c32cad8eb5cc0512f774a65da04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad77fb25bb894a5f1f091a4a94fa67b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77fb25bb894a5f1f091a4a94fa67b3f">&#9670;&nbsp;</a></span>REFL_DETAIL_ATTRIBUTES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REFL_DETAIL_ATTRIBUTES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">DeclType, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;static constexpr auto attributes{ ::refl::detail::make_attributes&lt;::refl::attr::usage:: DeclType&gt;(__VA_ARGS__) }; \</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expands to the appropriate attributes static member variable. </p>
<p>DeclType must be the name of one of the constraints defined in attr::usage. <b>VA_ARGS</b> is the list of attributes. </p>

</div>
</div>
<a id="adc29b89a87a223da5f194d5918ba94f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc29b89a87a223da5f194d5918ba94f5">&#9670;&nbsp;</a></span>REFL_DETAIL_FORCE_EBO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REFL_DETAIL_FORCE_EBO</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e6ab98a732ec684223ddfd0734f260f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6ab98a732ec684223ddfd0734f260f">&#9670;&nbsp;</a></span>REFL_DETAIL_GROUP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REFL_DETAIL_GROUP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;__VA_ARGS__</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to group input containing commas (e.g. </p>
<p>template specializations with multiple types). </p>

</div>
</div>
<a id="ac16abdfd738e4366eb239e904b90e930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16abdfd738e4366eb239e904b90e930">&#9670;&nbsp;</a></span>REFL_DETAIL_STR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REFL_DETAIL_STR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="refl_8hpp.html#a3eb9f0fdea25c64045020adb97393613">REFL_DETAIL_STR_IMPL</a>(__VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to stringify input separated by commas (e.g. </p>
<p>template specializations with multiple types). </p>

</div>
</div>
<a id="a3eb9f0fdea25c64045020adb97393613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb9f0fdea25c64045020adb97393613">&#9670;&nbsp;</a></span>REFL_DETAIL_STR_IMPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REFL_DETAIL_STR_IMPL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;#__VA_ARGS__</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7f8b46b069c2311101168d841a71b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f8b46b069c2311101168d841a71b37">&#9670;&nbsp;</a></span>REFL_DETAIL_TYPE_BODY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REFL_DETAIL_TYPE_BODY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TypeName, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="refl_8hpp.html#a4e6ab98a732ec684223ddfd0734f260f">REFL_DETAIL_GROUP</a> TypeName type; \</div><div class="line">        REFL_DETAIL_ATTRIBUTES(type, __VA_ARGS__) \</div><div class="line">        static constexpr <span class="keyword">auto</span> name{ <a class="code" href="namespacerefl_1_1util.html#af82b6c46a048b294ba533f7552d59bbf">::refl::util::make_const_string</a>(<a class="code" href="refl_8hpp.html#ac16abdfd738e4366eb239e904b90e930">REFL_DETAIL_STR</a>(<a class="code" href="refl_8hpp.html#a4e6ab98a732ec684223ddfd0734f260f">REFL_DETAIL_GROUP</a> TypeName)) }; \</div><div class="line">        static constexpr <span class="keywordtype">size_t</span> member_index_offset = __COUNTER__ + 1; \</div><div class="line">        template &lt;size_t, typename = void&gt; \</div><div class="line">        struct member {};</div><div class="ttc" id="namespacerefl_1_1util_html_af82b6c46a048b294ba533f7552d59bbf"><div class="ttname"><a href="namespacerefl_1_1util.html#af82b6c46a048b294ba533f7552d59bbf">refl::util::make_const_string</a></div><div class="ttdeci">constexpr const_string&lt; 1 &gt; make_const_string(char ch) noexcept</div><div class="ttdoc">Creates an instance of const_string&lt;N&gt;</div><div class="ttdef"><b>Definition:</b> refl.hpp:292</div></div>
<div class="ttc" id="refl_8hpp_html_a4e6ab98a732ec684223ddfd0734f260f"><div class="ttname"><a href="refl_8hpp.html#a4e6ab98a732ec684223ddfd0734f260f">REFL_DETAIL_GROUP</a></div><div class="ttdeci">#define REFL_DETAIL_GROUP(...)</div><div class="ttdoc">Used to group input containing commas (e.g.</div><div class="ttdef"><b>Definition:</b> refl.hpp:4016</div></div>
<div class="ttc" id="refl_8hpp_html_ac16abdfd738e4366eb239e904b90e930"><div class="ttname"><a href="refl_8hpp.html#ac16abdfd738e4366eb239e904b90e930">REFL_DETAIL_STR</a></div><div class="ttdeci">#define REFL_DETAIL_STR(...)</div><div class="ttdoc">Used to stringify input separated by commas (e.g.</div><div class="ttdef"><b>Definition:</b> refl.hpp:4014</div></div>
</div><!-- fragment -->
<p>Expands to the body of a type_info__ specialization. </p>

</div>
</div>
<a id="a2cb939da062920a29a38dff73aaf0968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb939da062920a29a38dff73aaf0968">&#9670;&nbsp;</a></span>REFL_MAKE_CONST_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REFL_MAKE_CONST_STRING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">CString</td><td>)</td>
          <td>&#160;&#160;&#160;(::refl::util::detail::copy_from_unsized&lt;::refl::util::detail::strlen(CString)&gt;(CString))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a compile-time available const char* value to a const_string&lt;N&gt;. </p>
<p>The argument must be a <em>core constant expression</em> and be null-terminated.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structrefl_1_1util_1_1const__string.html" title="Represents a compile-time string.">refl::util::const_string</a> </dd></dl>

</div>
</div>
<a id="a832b795bfa32d4130b04e9e33635c507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832b795bfa32d4130b04e9e33635c507">&#9670;&nbsp;</a></span>REFL_TEMPLATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REFL_TEMPLATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TemplateDeclaration, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TypeName, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">namespace </span>refl_impl::metadata { <span class="keyword">template</span> &lt;REFL_DETAIL_GROUP TemplateDeclaration&gt; <span class="keyword">struct </span>type_info__&lt;<a class="code" href="refl_8hpp.html#a4e6ab98a732ec684223ddfd0734f260f">REFL_DETAIL_GROUP</a> TypeName&gt; { \</div><div class="line">        REFL_DETAIL_TYPE_BODY(TypeName, __VA_ARGS__)</div><div class="ttc" id="refl_8hpp_html_a4e6ab98a732ec684223ddfd0734f260f"><div class="ttname"><a href="refl_8hpp.html#a4e6ab98a732ec684223ddfd0734f260f">REFL_DETAIL_GROUP</a></div><div class="ttdeci">#define REFL_DETAIL_GROUP(...)</div><div class="ttdoc">Used to group input containing commas (e.g.</div><div class="ttdef"><b>Definition:</b> refl.hpp:4016</div></div>
</div><!-- fragment -->
<p>Creates reflection information for a specified type template. </p>
<p>Takes an optional attribute list. TemplateDeclaration must be a panenthesis-enclosed list declaring the template parameters. (e.g. (typename A, typename B)). TypeName must be the fully-specialized type name and should also be enclosed in panenthesis. (e.g. (MyType&lt;A, B&gt;)) This macro must only be expanded in the global namespace.</p>
<p># Examples: </p><div class="fragment"><div class="line"><a class="code" href="refl_8hpp.html#a832b795bfa32d4130b04e9e33635c507">REFL_TEMPLATE</a>((<span class="keyword">typename</span> T), (std::vector&lt;T&gt;))</div><div class="line">...</div><div class="line">REFL_END</div></div><!-- fragment --> 
</div>
</div>
<a id="a2d90ffbabd9fc8cc17579fc33d919d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d90ffbabd9fc8cc17579fc33d919d71">&#9670;&nbsp;</a></span>REFL_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REFL_TYPE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TypeName, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">namespace </span>refl_impl::metadata { <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>type_info__&lt;TypeName&gt; { \</div><div class="line">        REFL_DETAIL_TYPE_BODY((TypeName), __VA_ARGS__)</div></div><!-- fragment -->
<p>Creates reflection information for a specified type. </p>
<p>Takes an optional attribute list. This macro must only be expanded in the global namespace.</p>
<p># Examples: </p><div class="fragment"><div class="line"><a class="code" href="refl_8hpp.html#a2d90ffbabd9fc8cc17579fc33d919d71">REFL_TYPE</a>(Point)</div><div class="line">...</div><div class="line">REFL_END</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="refl_8hpp.html">refl.hpp</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
